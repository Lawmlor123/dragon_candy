<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Little Dragon Flyer üêâ</title>
  <style>
    :root {
      color-scheme: light;
    }

    * {
      box-sizing: border-box;
    }

    body {
      margin: 0;
      min-height: 100vh;
      overflow: hidden;
      background: linear-gradient(to bottom, #87ceeb, #dff9fb);
      font-family: "Comic Sans MS", "Comic Neue", cursive, system-ui;
      color: #2c3e50;
    }

    canvas {
      display: block;
      width: 100vw;
      height: 100vh;
    }

    #scoreBoard {
      position: absolute;
      top: 10px;
      right: 10px;
      font-size: 22px;
      background: rgba(255, 255, 255, 0.65);
      padding: 6px 14px;
      border-radius: 10px;
      text-align: right;
      line-height: 1.3;
      z-index: 5;
    }

    #levelLabel {
      font-size: 18px;
      font-weight: 700;
      display: block;
      color: #2c3e50;
    }

    #scoreText {
      display: block;
      color: #2c3e50;
    }

    #overlay {
      position: absolute;
      top: 10px;
      left: 10px;
      background: rgba(255, 255, 255, 0.6);
      padding: 8px 14px;
      border-radius: 10px;
      font-size: 20px;
      z-index: 6;
      transition: opacity 0.4s ease;
    }

    #skipBtn {
      position: absolute;
      top: 10px;
      left: 50%;
      transform: translateX(-50%);
      font-size: 18px;
      background: rgba(255, 255, 255, 0.75);
      border: none;
      border-radius: 999px;
      padding: 6px 18px;
      cursor: pointer;
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
     transition: background-color 0.2s ease, transform 0.2s ease;
      z-index: 6;
    }

    #skipBtn:hover { background: rgba(255,255,255,0.9); }
    #skipBtn:active { transform: translateX(-50%) scale(0.96); }

    #winOverlay {
      display: none;
      position: absolute;
      top: 25%;
      left: 50%;
      transform: translate(-50%, -50%);
      font-size: 48px;
      color: #e74c3c;
      background: rgba(255, 255, 255, 0.88);
      padding: 30px 50px;
      border-radius: 16px;
      text-align: center;
      cursor: pointer;
      z-index: 10;
    }

    #lifeMeter {
      position: absolute;
      top: 10px;
      left: 50%;
      transform: translateX(-50%);
      font-size: 28px;
      letter-spacing: 6px;
      text-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
      pointer-events: none;
      display: none;
      z-index: 6;
    }

    #lifeMeter span { margin: 0 4px; }
    #lifeMeter span.lost { opacity: 0.35; }

    #startMusic {
      position: absolute;
      top: 10px;
      left: 10px;
      z-index: 9999;
      background: rgba(255, 255, 255, 0.9);
      border: 2px solid #333;
      border-radius: 8px;
      padding: 8px 14px;
      cursor: pointer;
      font-size: 18px;
    }

    #muteBtn {
      position: absolute;
      bottom: 10px;
      left: 10px;
      font-size: 20px;
      background: rgba(255, 255, 255, 0.6);
      border: none;
      border-radius: 8px;
      padding: 6px 12px;
      cursor: pointer;
      z-index: 6;
    }
@media (max-width: 600px) {
      #scoreBoard { font-size: 18px; line-height: 1.2; }
      #startMusic, #muteBtn { font-size: 16px; }
      #skipBtn { font-size: 16px; padding: 6px 14px; }
    }

/* --- touch control button styles --- */
#touchControls {
  position: absolute;
  bottom: calc(20px + env(safe-area-inset-bottom));
  left: 50%;
  transform: translateX(-50%);
  display: flex;              /* make sure it‚Äôs shown */
  gap: 20px;
  z-index: 12;
  align-items: center;
  justify-content: center;
  pointer-events: auto;
}

@media (hover: hover) and (pointer: fine) {
  #touchControls {
    display: none;            /* hide on desktop if desired */
  }
}

#touchControls button {
  font-size: 36px;
  background: rgba(255, 255, 255, 0.75);
  border: none;
  border-radius: 12px;
  padding: 14px 22px;
  box-shadow: 0 4px 8px rgba(0, 0, 0, 0.25);
  touch-action: manipulation; /* allows taps without scroll */
}

#touchControls button:active {
  transform: scale(0.9);
  background: rgba(255, 255, 255, 0.9);
}

/* prevent iOS scroll/zoom issues and make canvas touchable */
canvas {
  touch-action: none;
  user-select: none;
  -webkit-user-select: none;
  -webkit-touch-callout: none;
}
  </style>
</head>
<body>
  <button id="startMusic" type="button">üéµ Start Game Music</button>
  <button id="muteBtn" type="button" aria-label="Mute music">üîä</button>

  <div id="scoreBoard" aria-live="polite">
    <span id="levelLabel">Level 1</span>
    <span id="scoreText">Score: 0</span>
  </div>

<div id="overlay">Preparing launch‚Ä¶</div>
  <button id="skipBtn" type="button">Skip intro</button>
  <div id="lifeMeter" aria-label="Life meter"></div>
  <div id="winOverlay" role="dialog" aria-live="assertive">
    <strong>Victory!</strong><br />
    <small>Click to continue</small>
  </div>

  <canvas id="gameCanvas" aria-label="Little Dragon Flyer playfield"></canvas>
  <div id="touchControls">
    <button id="btnLeft">‚¨ÖÔ∏è</button>
    <button id="btnFlap">üïäÔ∏è</button>
    <button id="btnRight">‚û°Ô∏è</button>
  </div>


  <audio id="dayMusic"  src="Music/chase_fixed.mp3" preload="auto" loop></audio>
  <audio id="pulseMusic" src="Music/Pulse.mp3"        preload="auto" loop></audio>
  <audio id="rockMusic"  src="Music/storm.mp3"        preload="auto" loop></audio>

<script>
(function initMusicGate() {
  const musicElements = {
    day: document.getElementById("dayMusic"),
    pulse: document.getElementById("pulseMusic"),
    rock: document.getElementById("rockMusic")
  };

  function stopAllTracks(exceptKey = null) {
    Object.entries(musicElements).forEach(([key, track]) => {
      if (!track || key === exceptKey) return;
      track.pause();
      track.currentTime = 0;
    });
  }

  const startMusicBtn = document.getElementById("startMusic");
  if (!startMusicBtn) return;

  startMusicBtn.addEventListener("click", async () => {
    const dayTrack = musicElements.day;
    if (!dayTrack) {
      console.warn("dayMusic element not found.");
      return;
    }

    stopAllTracks("day");

    try {
      if (typeof ensureAudioContext === "function") {
        ensureAudioContext();
      }

      await dayTrack.play();

      if (typeof unlockMusic === "function") {
        unlockMusic();
      }

      startMusicBtn.disabled = true;
      startMusicBtn.textContent = "üéµ Music Ready";
    } catch (error) {
      console.error("Unable to start music:", error);
      alert(
        "The browser blocked the audio from starting.\n" +
        "Please click the button again (with sound enabled)."
      );
    }
  });
})();
</script>
<script>

/************************************************************
 * BASIC SETUP
 ************************************************************/

// Core canvas + UI references
const canvas = document.getElementById("gameCanvas");
const ctx = canvas.getContext("2d");
const scoreBoard = document.getElementById("scoreBoard");
const levelLabel = document.getElementById("levelLabel");
const scoreText = document.getElementById("scoreText");
const lifeMeter = document.getElementById("lifeMeter");
const winOverlay = document.getElementById("winOverlay");
const overlay = document.getElementById("overlay");
const skipBtn = document.getElementById("skipBtn");


// Enable keyboard focus for canvas
canvas.setAttribute("tabindex", "-1");
function focusCanvas() {
  if (document.activeElement !== canvas) {
    canvas.focus({ preventScroll: true });
  }
}

// Rescue‚Äëpod geometry (used for level hub visual)
const rescuePod = { x: 0, y: 0, radius: 150, glowPhase: 0 };
const podSlotOffsets = [
  { x: -0.65, y: -0.45 },
  { x: 0.65, y: -0.45 },
  { x: -0.95, y: 0.25 },
  { x: 0,    y: 0.4 },
  { x: 0.95, y: 0.25 }
];

// Canvas and geometry sizing
function updateRescuePodGeometry() {
  rescuePod.x = canvas.width / 2;
  rescuePod.y = canvas.height / 2;
  rescuePod.radius = Math.min(canvas.width, canvas.height) * 0.2;
}

function resizeCanvas() {
  canvas.width = innerWidth;
  canvas.height = innerHeight;
  updateRescuePodGeometry();
}

window.addEventListener("resize", resizeCanvas);
resizeCanvas();

/************************************************************
 * MUSIC
 ************************************************************/
const music = {
  day: document.getElementById("dayMusic"),
  rock: document.getElementById("rockMusic"),
  pulse: document.getElementById("pulseMusic")
};

const mechanicMusicPriority = {
  rescueGoal: "pulse",
  rhythmBounce: "pulse",
  scoreAvoid: "rock"
};

let musicUnlocked = false;
let pendingMusicType = null;

function deriveMusicType(levelIndex) {
  const fallback = "day";
  const level = levels[levelIndex];
  if (!level) return fallback;

  if (mechanicMusicPriority[level.mechanic]) {
    return mechanicMusicPriority[level.mechanic];
  }

  if (levelIndex >= 70) return "rock";
  if (levelIndex >= 35) return "pulse";
  return fallback;
}

function playMusic(type) {
  pendingMusicType = type;
  if (!musicUnlocked) return;

  Object.values(music)
    .filter(Boolean)
    .forEach(track => {
      track.pause();
      track.currentTime = 0;
    });

  const track = music[type];
  if (!track) return;

  track.volume = 0.7;
  track.play().catch(() => {});
}

function unlockMusic() {
  if (musicUnlocked) return;
  musicUnlocked = true;
  if (pendingMusicType) {
    const type = pendingMusicType;
    pendingMusicType = null;
    playMusic(type);
  }
}

function pickMusicForLevel(index) {
  const type = deriveMusicType(index);
  playMusic(type);
}

const muteBtn = document.getElementById("muteBtn");
if (muteBtn) {
  muteBtn.onclick = () => {
    const muted = !music.day?.muted;
    Object.values(music)
      .filter(Boolean)
      .forEach(track => (track.muted = muted));
    muteBtn.textContent = muted ? "üîá" : "üîä";
  };
}

/************************************************************
 * WEB AUDIO DINGS
 ************************************************************/
let audioCtx = null;

function ensureAudioContext() {
  if (!audioCtx) {
    audioCtx = new (window.AudioContext || window.webkitAudioContext)();
  }
  if (audioCtx.state === "suspended") {
    audioCtx.resume();
  }
  unlockMusic();
  return audioCtx;
}

function playTone(freq, duration, type = "sine", gainLevel = 0.18) {
  if (!ensureAudioContext()) return;

  const osc = audioCtx.createOscillator();
  const gain = audioCtx.createGain();

  osc.type = type;
  osc.frequency.value = freq;
  osc.connect(gain);
  gain.connect(audioCtx.destination);

  const now = audioCtx.currentTime;
  gain.gain.setValueAtTime(0.0001, now);
  gain.gain.exponentialRampToValueAtTime(gainLevel, now + 0.01);
  gain.gain.exponentialRampToValueAtTime(0.0001, now + duration);

  osc.start(now);
  osc.stop(now + duration + 0.05);
}

function playRhythmDing(quality) {
  const freq = quality === "perfect" ? 1100 : 880;
  playTone(freq, 0.18, "triangle", 0.22);
}

function playRhythmMiss() {
  playTone(160, 0.25, "sawtooth", 0.14);
}

/************************************************************
 * LEVELS + OBJECT TYPES
 ************************************************************/
const handcraftedLevels = new Map([
  [
    1,
    {
      name: "Balloon‚ÄØBash",
      mechanic: "scoreGoal",
      winScore: 400,
      bgGradient: ["#87ceeb", "#dff9fb"],
      control: "flap"
    }
  ],
  [
    2,
    {
      name: "Bubble‚ÄØPop",
      mechanic: "scoreGoal",
      winScore: 500,
      bgGradient: ["#a1c4fd", "#c2e9fb"],
      comboTime: 2000,
      control: "flap"
    }
  ],
  [
    3,
    {
      name: "Gem‚ÄØGlide",
      mechanic: "coinGoal",
      coinTarget: 10,
      coinValue: 1,
      bgGradient: ["#ffb88c", "#de6262"],
      control: "flap"
    }
  ],
  [
    4,
    {
      name: "Baby‚ÄØBuddies",
      mechanic: "rescueGoal",
      rescueGoal: 5,
      bgGradient: ["#141E30", "#243B55"],
      control: "arrow",
      useStars: true
    }
  ],
  [
    5,
    {
      name: "Moonrock Escort",
      mechanic: "escortPulse",
      bgGradient: ["#0f2027", "#203a43"],
      control: "rhythm",
      escort: {
        durationMs: 25000,
        maxStrikes: 5,
        targetShields: 9,
        shieldDecayMs: 3800,
        finaleHoldMs: 3500,
        moonRockSpeed: 560,
        hazardBurstInterval: 1500,
        goalName: "Golden Gate",
        stormName: "Moon Rock Tempest"
      }
    }
  ],
  [
    6,
    {
      name: "Rainbow‚ÄØRings",
      mechanic: "scoreAvoid",
      avoidType: "jellyfish",
      winScore: 900,
      bgGradient: ["#89f7fe", "#66a6ff"],
      control: "flap"
    }
  ],
  [
    7,
    {
      name: "Cave‚ÄØDrift",
      mechanic: "collectGoal",
      collectGoal: 10,
      winScore: 1000,
      bgGradient: ["#ffd89b", "#19547b"],
      control: "flap"
    }
  ],
  [
    8,
    {
      name: "Alphabet Jam",
      mechanic: "alphabetLoop",
      alphabetSequence: ["A", "B", "C", "D"],
      letterGoal: 4,
      allowOutOfOrder: false,
      bgGradient: ["#56ab2f", "#a8e063"],
      control: "flap"
    }
  ],
  [
    9,
    {
      name: "Number Glow",
      mechanic: "numberLoop",
      numberSequence: [1, 2, 3, 4],
      numberTimerMs: 28000,
      allowOutOfOrderNumbers: false,
      bubbleRadius: 48,
      bubblePalette: ["#ffbf69", "#ffd3b6", "#c7f9cc", "#a0c4ff"],
      bgGradient: ["#ff9a9e", "#fad0c4"],
      control: "flap"
    }
  ],
  [
    10,
    {
      name: "Math‚ÄØBubble‚ÄØBuddies",
      mechanic: "rescueGoal",
      rescueGoal: 2,
      bgGradient: ["#f6d365", "#fda085"],
      control: "arrow",
      mathBubble: true,
      useStars: false,
      mathEquation: "1 + 1 = 2"
    }
  ],
  [
    11,
    {
      name: "Coral‚ÄØSoar",
      mechanic: "scoreGoal",
      winScore: 1280,
      bgGradient: ["#FF61D2", "#FE9090"],
      control: "flap"
    }
  ],
  [
    13,
    {
      name: "Crystal‚ÄØSurge",
      mechanic: "scoreCollect",
      collectGoal: 9,
      winScore: 1500,
      bgGradient: ["#7F7FD5", "#86A8E7"],
      control: "flap"
    }
  ], // ‚úÖ Missing comma fixed here!
  [
    20,
    {
      name: "Math‚ÄØBubble‚ÄØTrio",
      mechanic: "rescueGoal",
      rescueGoal: 3,
      bgGradient: ["#fbc2eb", "#a6c1ee"],
      control: "arrow",
      mathBubble: true,
      useStars: false,
      mathEquation: "1 + 1 + 1 = 3"
    }
  ] // ‚úÖ No comma after final entry
]); // ‚úÖ Properly closes the Map
/************************************************************
 * ALPHABET LOOP HELPERS
 ************************************************************/
const ALPHABET = "ABCDEFGHIJKLMNOPQRSTUVWXYZ".split("");
const LETTERS_PER_ALPHABET_LEVEL = 4;

function getAlphabetSequenceForLevel(levelNumber) {
  const chunkIndex = Math.floor(levelNumber / 10);
  const alphabetSequence = [];
  for (let i = 0; i < LETTERS_PER_ALPHABET_LEVEL; i++) {
    const letterIndex = chunkIndex * LETTERS_PER_ALPHABET_LEVEL + i;
    alphabetSequence.push(ALPHABET[letterIndex % ALPHABET.length]);
  }
  return alphabetSequence;
}

function syncHandcraftedAlphabetLoops() {
  const alphabetLoopEntries = Array.from(handcraftedLevels.entries())
    .filter(([, config]) => config.mechanic === "alphabetLoop")
    .sort((a, b) => a[0] - b[0]);

  alphabetLoopEntries.forEach(([levelNumber, config]) => {
    const alphabetSequence = getAlphabetSequenceForLevel(levelNumber);
    config.alphabetSequence = alphabetSequence;
    config.letterGoal = alphabetSequence.length;
  });
}
/************************************************************
 * ALPHABET STATE RESET
 ************************************************************/
function resetAlphabetState(level) {
  // Turn off the alphabet game mode by default
  alphabetState.active = false;
  alphabetState.targetLetters = [];
  alphabetState.collected = [];
  alphabetState.allowOutOfOrder = false;
  alphabetState.timerMs = 0;
  alphabetState.timerStart = 0;
  alphabetState.failTriggered = false;
  alphabetState.letters = [];

  if (!level || level.mechanic !== "alphabetLoop") return;

  // Initialize alphabet mode
  alphabetState.active = true;
  alphabetState.targetLetters = Array.isArray(level.alphabetSequence)
    ? level.alphabetSequence.slice()
    : getAlphabetSequenceForLevel(level.levelNumber ?? 1);
  alphabetState.collected = [];
  alphabetState.allowOutOfOrder = !!level.allowOutOfOrder;
  alphabetState.timerMs = level.timerMs || 30000;
  alphabetState.timerStart = performance.now();
  alphabetState.failTriggered = false;
  alphabetState.letters = [];

  const colors =
    Array.isArray(alphabetBubblePalette) && alphabetBubblePalette.length
      ? alphabetBubblePalette
      : ["#f97316", "#fbbf24", "#34d399", "#38bdf8", "#a855f7"];

  const count = alphabetState.targetLetters.length;
  for (let i = 0; i < count; i++) {
    alphabetState.letters.push({
      letter: alphabetState.targetLetters[i],
      x: 160 + Math.random() * (canvas.width - 320),
      y: 160 + Math.random() * (canvas.height - 280),
      radius: 36,
      active: true,
      color: colors[i % colors.length]
    });
  }
}
/************************************************************
 * NUMBER LOOP HELPERS
 ************************************************************/
const NUMBERS_PER_NUMBER_LEVEL = 4;
const NUMBER_SEQUENCE_START = 1;

function getNumberSequenceForLevel(levelNumber) {
  const chunkIndex = Math.floor(levelNumber / 10);
  const start = NUMBER_SEQUENCE_START + chunkIndex * NUMBERS_PER_NUMBER_LEVEL;
  const numberSequence = [];
  for (let i = 0; i < NUMBERS_PER_NUMBER_LEVEL; i++) {
    numberSequence.push(start + i);
  }
  return numberSequence;
}

function syncHandcraftedNumberLoops() {
  const numberLoopEntries = Array.from(handcraftedLevels.entries())
    .filter(([, config]) => config.mechanic === "numberLoop")
    .sort((a, b) => a[0] - b[0]);

  numberLoopEntries.forEach(([levelNumber, config]) => {
    const numberSequence = getNumberSequenceForLevel(levelNumber);
    config.numberSequence = numberSequence;
    config.numberSequenceLength = numberSequence.length;
  });
}

/************************************************************
 * NUMBER STATE RESET
 ************************************************************/
function resetNumberState(level) {
  numberState.active = false;
  numberState.allowOutOfOrder = false;
  numberState.sequence = [];
  numberState.nodes = [];
  numberState.collected = [];
  numberState.currentIndex = 0;
  numberState.timerMs = 0;
  numberState.timerStart = 0;
  numberState.failTriggered = false;

  if (!level || level.mechanic !== "numberLoop") return;

  numberState.active = true;
  numberState.allowOutOfOrder = !!level.allowOutOfOrderNumbers;
  numberState.sequence = Array.isArray(level.numberSequence)
    ? level.numberSequence.slice()
    : getNumberSequenceForLevel(level.levelNumber ?? 1);
  numberState.nodes = [];
  numberState.collected = [];
  numberState.currentIndex = 0;
  numberState.timerMs = level.numberTimerMs || 30000;
  numberState.timerStart = performance.now();
  numberState.failTriggered = false;

  const colors = Array.isArray(numberBubblePalette) && numberBubblePalette.length
    ? numberBubblePalette
    : ["#fde68a", "#fbcfe8", "#bae6fd", "#c7d2fe", "#fecdd3", "#bbf7d0"];

  const count = numberState.sequence.length;
  for (let i = 0; i < count; i++) {
    numberState.nodes.push({
      value: numberState.sequence[i],
      x: 160 + Math.random() * (canvas.width - 320),
      y: 160 + Math.random() * (canvas.height - 280),
      radius: numberState.bubbleRadius ?? 44,
      active: true,
      color: colors[i % colors.length],
      pulseOffset: Math.random() * 6.28
    });
  }
}


const alphabetState = {
  active: false,
  targetLetters: [],
  collected: [],
  allowOutOfOrder: false,
  timerMs: 0,
  timerStart: 0,
  failTriggered: false
};

const numberState = {
  active: false,
  allowOutOfOrder: false,
  sequence: [],
  nodes: [],
  collected: [],
  timerMs: 0,
  timerStart: 0,
  failTriggered: false,
  currentIndex: 0,
  bubbleRadius: 44
};
/************************************************************
 * EQUATION DISPLAY STATE (for Level‚ÄØ10)
 ************************************************************/
const equationState = {
  active: false,
  partsShown: 0,
  text: "",
  shownAt: 0
};
const mathBubbleLevels = new Set([10, 20]);
let currentMathEquation = "";
let mathBubbleStage = 0;
let mathBubbleRevealTimeout = null;
let mathBubbleTokens = [];
let mathBubbleStageBreakpoints = [];
let currentLevel = null;
let currentLevelIndex = 0;
if (currentLevel === null) currentLevel = 0; // üåç ensure starting level is 0
let flightStarted = false;
let levelEnding = false;
let score = 0;

const bgPalette = [
  ["#87ceeb", "#dff9fb"],
  ["#a1c4fd", "#c2e9fb"],
  ["#ffb88c", "#de6262"],
  ["#141E30", "#243B55"],
  ["#ffdde1", "#ee9ca7"],
  ["#89f7fe", "#66a6ff"],
  ["#ffd89b", "#19547b"],
  ["#56ab2f", "#a8e063"],
  ["#ff9a9e", "#fad0c4"],
  ["#00c6ff", "#0072ff"],
  ["#fdfbfb", "#ebedee"],
  ["#f6d365", "#fda085"],
  ["#cfd9df", "#e2ebf0"],
  ["#43cea2", "#185a9d"],
  ["#c33764", "#1d2671"],
  ["#ff9966", "#ff5e62"]
];

const alphabetBubblePalette = [
  "#f97316",
  "#fbbf24",
  "#34d399",
  "#38bdf8",
  "#a855f7",
  "#ec4899"
];

const numberBubblePalette = [
  "#fde68a",
  "#fbcfe8",
  "#bae6fd",
  "#c7d2fe",
  "#fecdd3",
  "#bbf7d0"
];

const nameFragments = {
  prefix: [
    "Balloon",
    "Bubble",
    "Gem",
    "Sky",
    "Rainbow",
    "Cloud",
    "Star",
    "Cave",
    "Aurora",
    "Luna",
    "Coral",
    "Comet",
    "Crystal",
    "Sunset",
    "Willow",
    "Zephyr"
  ],
  suffix: [
    "Bash",
    "Bloom",
    "Rush",
    "Rhythm",
    "Rescue",
    "Reef",
    "Rally",
    "Voyage",
    "Drift",
    "Dance",
    "Soar",
    "Serenade",
    "Surge",
    "Symphony",
    "Sprint",
    "Saga"
  ],
  suffixByMechanic: {
    rescueGoal: ["Rescue", "Guardians", "Guard", "Patrol", "Hatchlings"],
    rhythmBounce: ["Rhythm", "Cadence", "Groove", "Tempo", "Anthem"],
    escortPulse: ["Escort", "Guard", "Bulwark", "Sentinel", "Pulse"]
  }
};

const levelArchetypes = {
  scoreGoal: ({ levelNumber, name, bgGradient }) => ({
    name,
    mechanic: "scoreGoal",
    winScore: 400 + levelNumber * 80,
    bgGradient,
    control: "flap"
  }),
  comboGoal: ({ levelNumber, name, bgGradient }) => ({
    name,
    mechanic: "comboGoal",
    winScore: 450 + levelNumber * 85,
    comboTime: Math.max(1200, 2400 - levelNumber * 15),
    bgGradient,
    control: "flap"
  }),
  coinGoal: ({ levelNumber, name, bgGradient }) => ({
    name,
    mechanic: "coinGoal",
    coinTarget: 8 + Math.ceil(levelNumber / 2),
    coinValue: 1,
    bgGradient,
    control: "flap"
  }),
  scoreCollect: ({ levelNumber, name, bgGradient }) => ({
    name,
    mechanic: "scoreCollect",
    collectGoal: 4 + Math.ceil(levelNumber / 4),
    winScore: 500 + levelNumber * 85,
    bgGradient,
    control: "flap"
  }),
  collectGoal: ({ levelNumber, name, bgGradient }) => ({
    name,
    mechanic: "collectGoal",
    collectGoal: 6 + Math.ceil(levelNumber / 3),
    winScore: 480 + levelNumber * 90,
    bgGradient,
    control: "flap"
  }),
  rescueGoal: ({ levelNumber, name, bgGradient }) => ({
    name,
    mechanic: "rescueGoal",
    rescueGoal: 5 + Math.floor(levelNumber / 5),
    bgGradient,
    control: "arrow",
    useStars: true
  }),
  rhythmBounce: ({ levelNumber, name, bgGradient }) => ({
    name,
    mechanic: "rhythmBounce",
    bgGradient,
    control: "rhythm",
    rhythm: generateRhythmConfig(levelNumber)
  }),
  escortPulse: ({ levelNumber, name, bgGradient }) => ({
    name,
    mechanic: "escortPulse",
    bgGradient,
    control: "rhythm",
    escort: generateEscortConfig(levelNumber)
  }),
  alphabetLoop: ({ levelNumber, name, bgGradient }) => {
    const alphabetSequence = getAlphabetSequenceForLevel(levelNumber);
    return {
      name,
      mechanic: "alphabetLoop",
      alphabetSequence,
      alphabetSequenceLength: alphabetSequence.length,
      letterGoal: alphabetSequence.length,
      allowOutOfOrder: levelNumber >= 30,
      timerMs: 45000 - Math.min(15000, levelNumber * 400),
      bgGradient,
      control: "flap"
    };
  },
  numberLoop: ({ levelNumber, name, bgGradient }) => ({
    name,
    mechanic: "numberLoop",
    numberSequenceLength: 3 + Math.floor(levelNumber / 8),
    numberTimerMs: 30000 - Math.min(12000, levelNumber * 220),
    allowOutOfOrderNumbers: levelNumber >= 45,
    bubbleRadius: 44,
    bgGradient,
    control: "flap"
  })
};

function pickMechanic(levelNumber) {
  if (levelNumber % 10 === 8) return "alphabetLoop";
  if (levelNumber % 10 === 9) return "numberLoop";
  if (levelNumber % 10 === 0) return "rescueGoal";
  if (levelNumber % 10 === 5) return "escortPulse";
  if (levelNumber % 5 === 0) return "rhythmBounce";
  const rotation = ["scoreGoal", "coinGoal", "scoreCollect", "comboGoal", "collectGoal"];
  return rotation[(levelNumber - 1) % rotation.length];
}

function pickGradient(levelNumber) {
  return bgPalette[(levelNumber - 1) % bgPalette.length];
}

function generateLevelName(levelNumber, mechanic) {
  const prefix = nameFragments.prefix[(levelNumber - 1) % nameFragments.prefix.length];
  const suffixPool = nameFragments.suffixByMechanic[mechanic] ?? nameFragments.suffix;
  const suffix = suffixPool[(levelNumber - 1) % suffixPool.length];
  return `${prefix} ${suffix}`;
}

function generateRhythmConfig(levelNumber) {
  const bpm = 96 + (levelNumber % 5) * 4;
  const beats = Math.min(18, 6 + Math.floor(levelNumber / 3));
  const beatInterval = Math.round((60 / bpm) * 1000);
  const beatMap = [];
  for (let i = 0; i < beats; i++) {
    beatMap.push({
      time: 1800 + i * beatInterval,
      lane: i % 2 === 0 ? "left" : "right"
    });
  }
  return {
    mode: levelNumber % 2 === 0 ? "dualLane" : "singleLane",
    bpm,
    targetBounces: beats,
    windowPerfect: 150,
    windowGood: 300,
    preDisplay: 1200,
    maxMisses: Math.min(6, 3 + Math.floor(levelNumber / 15)),
    leadTime: 2400,
    beatMap
  };
}

function generateEscortConfig(levelNumber) {
  const durationMs = 22000 + Math.min(4000, levelNumber * 120);
  const hazardBurstInterval = Math.max(1100, 2000 - levelNumber * 45);

  const isLevel15 = levelNumber === 15;
  const speedModifier = isLevel15 ? 0.5 : 1;
  const burstModifier = isLevel15 ? 1.5 : 1;

  return {
    durationMs,
    maxStrikes: 5 + Math.floor(levelNumber / 25),
    targetShields: 7 + Math.floor(levelNumber / 4),
    shieldDecayMs: 3600,
    finaleHoldMs: 2800,
    moonRockSpeed: (480 + levelNumber * 8) * speedModifier,
    hazardBurstInterval: hazardBurstInterval * burstModifier,
    goalName: "Sky Gate",
    stormName: "Lunar Gale"
  };
}

function cloneLevelConfig(config) {
  return JSON.parse(JSON.stringify(config));
}

function buildLevels(totalLevels = 100) {
  const generated = [];
  for (let levelNumber = 1; levelNumber <= totalLevels; levelNumber++) {
    if (handcraftedLevels.has(levelNumber)) {
      generated.push(cloneLevelConfig(handcraftedLevels.get(levelNumber)));
      continue;
    }

    const mechanic = pickMechanic(levelNumber);
    const bgGradient = pickGradient(levelNumber);
    const name = generateLevelName(levelNumber, mechanic);
    const factory = levelArchetypes[mechanic];

    if (!factory) {
      console.warn(`No archetype found for mechanic "${mechanic}". Falling back to scoreGoal.`);
      generated.push(
        levelArchetypes.scoreGoal({ levelNumber, name, bgGradient })
      );
      continue;
    }

    generated.push(factory({ levelNumber, name, bgGradient }));
  }
  return generated;
}
const levels = buildLevels();
syncHandcraftedAlphabetLoops();
syncHandcraftedNumberLoops();

/************************************************************
 * RHYTHM STATE
 ************************************************************/
const rhythmDefaults={
  mode:"bounce",
  bpm:112,
  targetBounces:15,
  windowPerfect:110,
  windowGood:220,
  preDisplay:1200,
  maxMisses:3,
  leadBeats:6,
  leadTime:null,
  beatMap:[]
};
const rhythmState={
  active:false,
  mode:"bounce",
  config:{...rhythmDefaults},
  startTime:0,
  sequenceStart:0,
  nextBeatTime:0,
  clouds:[],
  notes:[],
  activeNotes:[],
  bounces:0,
  hits:0,
  perfectHits:0,
  combo:0,
  misses:0,
  failPending:false
};
function isRescueLevel() {
  return levels[currentLevel]?.mechanic === "rescueGoal";
}
function isRhythmLevel() {
  return levels[currentLevel]?.mechanic === "rhythmBounce";
}
function isAlphabetLevel(level = levels[currentLevel]) {
  return level?.mechanic === "alphabetLoop";
}
function isNumberLevel(level = levels[currentLevel]) {
  return level?.mechanic === "numberLoop";
}

function isMathBubbleLevel(level = levels[currentLevel]) {
  if (!level) return false;
  const levelNumber = level.levelNumber ?? currentLevel + 1;
  return mathBubbleLevels.has(levelNumber);
}

function resetRhythmState(level){
  if(level.mechanic!=="rhythmBounce"){
    rhythmState.active=false;
    rhythmState.clouds=[];
    rhythmState.notes=[];
    rhythmState.activeNotes=[];
    lifeMeter.style.display="none";
    rhythmState.failPending=false;
    return;
  }
  const cfg={...rhythmDefaults,...(level.rhythm||{})};
  cfg.bpm=Math.max(1,cfg.bpm||rhythmDefaults.bpm);
  cfg.msPerBeat=60000/cfg.bpm;
  cfg.maxMisses=Math.max(1,cfg.maxMisses??rhythmDefaults.maxMisses);
  if(!cfg.leadTime){
    cfg.leadTime=(cfg.leadBeats||6)*cfg.msPerBeat;
  }
  if(cfg.mode==="dualLane" && (!cfg.targetBounces || cfg.targetBounces<=0)){
    const beatCount=cfg.beatMap?.length||0;
    cfg.targetBounces=beatCount>0?beatCount:rhythmDefaults.targetBounces;
  }
  rhythmState.active=true;
  rhythmState.config=cfg;
  rhythmState.mode=cfg.mode||"bounce";
  rhythmState.clouds=[];
  rhythmState.notes=[];
  rhythmState.activeNotes=[];
  rhythmState.bounces=0;
  rhythmState.hits=0;
  rhythmState.perfectHits=0;
  rhythmState.combo=0;
  rhythmState.misses=0;
  rhythmState.failPending=false;
  const now=performance.now();
  rhythmState.startTime=now;
  if(rhythmState.mode==="dualLane"){
    rhythmState.sequenceStart=now+cfg.preDisplay;
    rhythmState.notes=prepareDualLaneNotes(cfg);
  }else{
    rhythmState.sequenceStart=now;
    rhythmState.nextBeatTime=now+cfg.preDisplay;
  }
  updateRhythmScoreboard();
  updateLifeMeter();
}
function prepareDualLaneNotes(cfg){
  const allowance=Math.max(0,cfg.maxMisses||0);
  const requiredBeats=Math.max(cfg.targetBounces+allowance,cfg.targetBounces);
  const baseMap=Array.isArray(cfg.beatMap)
    ? cfg.beatMap.map(note=>({
        time:typeof note.time==="number"?note.time:0,
        lane:note.lane||null
      }))
    : [];
  ensureDualLaneBeatSupply(baseMap,cfg,requiredBeats);
  return baseMap.map((note,index)=>({
    time:note.time,
    lane:note.lane|| (index%2===0?"left":"right"),
    index,
    spawned:false,
    hit:false,
    result:null,
    y:canvas.height*0.12,
    progress:0,
    hitTime:0
  }));
}
function ensureDualLaneBeatSupply(baseMap, cfg, targetLength) {
  if (baseMap.length >= targetLength) return baseMap;

  const lanes = cfg.mode === "dualLane" ? ["left", "right"] : ["left"];
  let laneCursor = baseMap.length;

  if (baseMap.length) {
    const lastLane = baseMap[baseMap.length - 1].lane;
    const idx = lanes.indexOf(lastLane);
    if (idx >= 0) laneCursor = idx + 1;
  } else {
    laneCursor = 0;
  }

  let lastTime = baseMap.length
    ? (typeof baseMap[baseMap.length - 1].time === "number"
        ? baseMap[baseMap.length - 1].time
        : cfg.preDisplay)
    : (cfg.preDisplay ?? 0);

  const step = Math.max(120, cfg.msPerBeat || 600);

  while (baseMap.length < targetLength) {
    lastTime += step;
    const lane = lanes[(laneCursor++) % lanes.length] || "left";
    baseMap.push({ time: lastTime, lane });
  }

  return baseMap;
}

function updateRhythmScoreboard() {
  if (!isRhythmLevel()) return;

  if (rhythmState.mode === "dualLane") {
    scoreText.textContent = `Hits ${rhythmState.hits}/${rhythmState.config.targetBounces}`;
  } else {
    scoreText.textContent = `Bounces ${rhythmState.bounces}/${rhythmState.config.targetBounces}`;
  }
}

function updateLifeMeter() {
  if (!isRhythmLevel()) {
    lifeMeter.style.display = "none";
    return;
  }

  lifeMeter.style.display = "block";
  const max = rhythmState.config.maxMisses;
  let html = "";

for (let i = 0; i < max; i++) {
  const lost = i < rhythmState.misses;
  html += `<span class="${lost ? 'lost' : ''}">${lost ? 'ü§ç' : '‚ù§Ô∏è'}</span>`;
}

  lifeMeter.innerHTML = html;
}
function createRhythmCloud(beatTime,index){
  const laneOffsets=[-140,-80,-20,40];
  return {
    beatTime,
    index,
    laneOffset:laneOffsets[index%laneOffsets.length],
    state:"pending",
    hitQuality:null,
    xFactor:0.34+Math.random()*0.18,
    radius:55
  };
}
function getCloudPosition(cloud){
  const x=canvas.width*cloud.xFactor;
  const y=canvas.height*0.62+cloud.laneOffset;
  return {x,y};
}
function registerRhythmMiss(cloud){
  if(!cloud||cloud.state!=="pending"||rhythmState.failPending)return;
  cloud.state="missed";
  rhythmState.misses++;
  playRhythmMiss();
  updateLifeMeter();
  const pos=getCloudPosition(cloud);
  popTexts.push({x:pos.x,y:pos.y-35,text:"Miss!",color:"#e74c3c",life:1});
  triggerRhythmDip();
  if(rhythmState.misses>=rhythmState.config.maxMisses&&!rhythmState.failPending){
    rhythmState.failPending=true;
    popTexts.push({x:canvas.width/2,y:canvas.height/2-50,text:"Restarting...",color:"#ffffff",life:1.2});
    setTimeout(()=>loadLevel(currentLevel),900);
  }
}
function getDualLaneX(lane){
  return lane==="left"?canvas.width*0.35:canvas.width*0.65;
}
function getDualLanePosition(note){
  const lane=(note&&note.lane)?note.lane:"left";
  const yPos=(note&&typeof note.y==="number")?note.y:canvas.height*0.8;
  return {
    x:getDualLaneX(lane),
    y:yPos
  };
}
function registerDualLaneMiss(note){
  if(!note || note.hit)return;
  note.hit=true;
  note.result="miss";
  note.hitTime=performance.now();
  rhythmState.misses++;
  rhythmState.combo=0;
  playRhythmMiss();
  const pos=getDualLanePosition(note);
  popTexts.push({x:pos.x,y:pos.y-35,text:"Miss!",color:"#ff7a85",life:1});
  triggerRhythmDip();
  updateLifeMeter();
  if(rhythmState.misses>=rhythmState.config.maxMisses&&!rhythmState.failPending){
    rhythmState.failPending=true;
    popTexts.push({x:canvas.width/2,y:canvas.height/2-50,text:"Restarting...",color:"#ffffff",life:1.2});
    setTimeout(()=>loadLevel(currentLevel),900);
  }
}
/************************************************************
 * RHYTHM INPUT + UPDATE LOGIC
 ************************************************************/

function handleRhythmInput(lane = null) {
  if (!isRhythmLevel() || !rhythmState.active || rhythmState.failPending) return;
  ensureAudioContext();
  rhythmTapBoost();

  // --- Dual‚Äëlane handling ---
  if (rhythmState.mode === "dualLane") {
    const laneToUse = lane || getClosestLaneToBeat();
    if (!laneToUse) return;
    handleDualLaneInput(laneToUse);
    return;
  }

  // --- Single‚Äëlane handling ---
  const now = performance.now();
  let target = null;
  let bestDiff = Infinity;

  for (const cloud of rhythmState.clouds) {
    if (cloud.state !== "pending") continue;

    const diff = Math.abs(now - cloud.beatTime);
    if (diff < bestDiff) {
      bestDiff = diff;
      target = cloud;
    }
  }

  if (!target || bestDiff > rhythmState.config.windowGood) return;

  target.state = "hit";
  const quality = bestDiff <= rhythmState.config.windowPerfect ? "perfect" : "good";
  target.hitQuality = quality;

  const pos = getCloudPosition(target);
  popTexts.push({
    x: pos.x,
    y: pos.y - 40,
    text: quality === "perfect" ? "Perfect!" : "Good!",
    color: quality === "perfect" ? "#ffe066" : "#9b59b6",
    life: 1
  });

  rhythmState.bounces++;
  updateRhythmScoreboard();
  triggerRhythmBounce(quality);
  playRhythmDing(quality);
  emitFireBurst();

  if (rhythmState.bounces >= rhythmState.config.targetBounces) {
    levelComplete();
  }
}

function getClosestLaneToBeat() {
  const now = performance.now();
  const seqStart = rhythmState.sequenceStart;
  let closest = null;

  for (const note of rhythmState.activeNotes) {
    if (note.hit) continue;
    const targetTime = seqStart + note.time;
    const delta = Math.abs(targetTime - now);
    if (delta > rhythmState.config.windowGood) continue;
    if (!closest || delta < closest.delta) {
      closest = { lane: note.lane, delta };
    }
  }

  return closest ? closest.lane : "left";
}

function handleDualLaneInput(lane) {
  ensureAudioContext();
  const now = performance.now();
  const seqStart = rhythmState.sequenceStart;
  const candidates = rhythmState.activeNotes
    .filter(note => !note.hit && note.lane === lane)
    .sort((a, b) => {
      const ta = Math.abs((seqStart + a.time) - now);
      const tb = Math.abs((seqStart + b.time) - now);
      return ta - tb;
    });

  if (!candidates.length) return;
  const note = candidates[0];
  const noteTime = seqStart + note.time;
  const delta = Math.abs(noteTime - now);

  if (delta <= rhythmState.config.windowPerfect) {
    processDualLaneResult(note, "perfect", delta);
  } else if (delta <= rhythmState.config.windowGood) {
    processDualLaneResult(note, "good", delta);
  }
  // Out-of-window taps are ignored
}

function processDualLaneResult(note, result, delta) {
  if (note.hit) return;
  note.hit = true;
  note.result = result;
  note.hitTime = performance.now();
  rhythmState.hits++;
  if (result === "perfect") rhythmState.perfectHits++;
  rhythmState.combo = (rhythmState.combo || 0) + 1;

  const pos = getDualLanePosition(note);
  popTexts.push({
    x: pos.x,
    y: pos.y - 45,
    text:
      result === "perfect"
        ? `Perfect (${delta.toFixed(0)}‚ÄØms)`
        : `Good (${delta.toFixed(0)}‚ÄØms)`,
    color: result === "perfect" ? "#89ffde" : "#ffd479",
    life: 1
  });

  triggerRhythmBounce(result);
  playRhythmDing(result);
  emitFireBurst();
  updateRhythmScoreboard();

  if (rhythmState.hits >= rhythmState.config.targetBounces) {
    levelComplete();
  }
}

function triggerRhythmBounce(quality) {
  const boost = quality === "perfect" ? -9 : -7;
  dragon.velocity = boost;
}

function triggerRhythmDip() {
  dragon.velocity = Math.max(dragon.velocity, 4);
}

function updateDualLaneLevel(now) {
  const cfg = rhythmState.config;
  const seqStart = rhythmState.sequenceStart;

  // Spawn notes when within leadTime of target
  rhythmState.notes.forEach(note => {
    const noteTime = seqStart + note.time;
    if (!note.spawned && now >= noteTime - cfg.leadTime) {
      note.spawned = true;
      note.hit = false;
      note.result = null;
      note.y = canvas.height * 0.12;
      note.progress = 0;
      rhythmState.activeNotes.push(note);
    }
  });

  // Move and clean up existing notes
  rhythmState.activeNotes.forEach(note => {
    const noteTime = seqStart + note.time;
    const timeUntilHit = noteTime - now;
    note.progress = 1 - (timeUntilHit / cfg.leadTime);
    const travelTop = canvas.height * 0.12;
    const hitLine = canvas.height * 0.8;
    const clampedProgress = Math.min(Math.max(note.progress, 0), 1);
    note.y = travelTop + (hitLine - travelTop) * clampedProgress;

    if (!note.hit && now - noteTime > cfg.windowGood) {
      registerDualLaneMiss(note);
    }
  });

  rhythmState.activeNotes = rhythmState.activeNotes.filter(note => {
    const noteTime = seqStart + note.time;
    if (note.hit) return now - note.hitTime < 400;
    return now - noteTime < 700;
  });
}

function updateRhythmLevel(now) {
  if (!rhythmState.active) return;
  if (rhythmState.mode === "dualLane") {
    updateDualLaneLevel(now);
    return;
  }

  const cfg = rhythmState.config;
  while (rhythmState.nextBeatTime < now + cfg.leadTime) {
    rhythmState.clouds.push(
      createRhythmCloud(rhythmState.nextBeatTime, rhythmState.clouds.length)
    );
    rhythmState.nextBeatTime += cfg.msPerBeat;
  }

  rhythmState.clouds.forEach(cloud => {
    if (cloud.state === "pending" && now > cloud.beatTime + cfg.windowGood) {
      registerRhythmMiss(cloud);
    }
  });

  rhythmState.clouds = rhythmState.clouds.filter(
    cloud =>
      now < cloud.beatTime + cfg.preDisplay + 1200 || cloud.state === "hit"
  );
}
/************************************************************
 * MONEY + RESCUE HELPERS
 ************************************************************/
const MONEY_SYMBOL = "$";

function formatMoney(value) {
  return `${MONEY_SYMBOL}${Number.isInteger(value) ? value : value.toFixed(2)}`;
}

function updateCoinScoreboard(level) {
  const target = level?.coinTarget ?? 0;
  scoreText.textContent = `Bank ${formatMoney(coinBank)}/${formatMoney(target)}`;
}

function updateRescueScoreboard(level) {
  const L = level || levels[currentLevel];
  if (!L) return;

  if (isMathBubbleLevel(L)) {
    const goal = typeof L.rescueGoal === "number" ? L.rescueGoal : 0;
    const equation = currentMathEquation || L.mathEquation || "1 + 1 = 2";
    scoreText.textContent = `üßÆ ${equation} ‚Äî ${rescuedCount}/${goal}`;
  } else {
    const goal = typeof L.rescueGoal === "number" ? L.rescueGoal : 0;
    scoreText.textContent = `Rescued ${rescuedCount}/${goal}`;
  }
}

function updateScoreboardForLevel(level) {
  if (!level) return;

  switch (level.mechanic) {
    case "coinGoal":
      updateCoinScoreboard(level);
      break;
    case "rescueGoal":
      updateRescueScoreboard(level);
      break;
    case "collectGoal":
    case "scoreCollect":
      scoreText.textContent = `Collected ${collected}/${level.collectGoal || 0}`;
      break;
    case "alphabetLoop":
      scoreText.textContent = `Letters ${alphabetState.collected.length}/${alphabetState.targetLetters.length}`;
      break;
    case "numberLoop":
      scoreText.textContent = `Numbers ${numberState.collected.length}/${numberState.sequence.length}`;
      break;
    case "rhythmBounce":
      updateRhythmScoreboard();
      break;
    default:
      scoreText.textContent = `Score ${score}/${level.winScore || 0}`;
      break;
  }
}

/************************************************************
 * COMBO VARIABLES
 ************************************************************/
let comboCount = 0;
let lastPopTime = 0;
let comboTextTimer = 0;

/************************************************************
 * DRAGON + EFFECTS
 ************************************************************/
const dragon = {
  x: 120,
  y: 220,
  radius: 40,
  velocity: 0,
  vx: 0,
  gravity: 0.2,
  flapStrength: -8.5,
  wingTimer: 0,
  color: "#e74c3c"
};
/************************************************************
 * OBJECT POOL
 ************************************************************/
const objects = [];

const particles = [];
const fireParticles = [];

function addParticle() {
  particles.push({
    x: dragon.x - dragon.radius / 2 + Math.random() * 8 - 4,
    y: dragon.y + Math.random() * 8 - 4,
    radius: 3 + Math.random() * 3,
    opacity: 1
  });
  if (particles.length > 100) particles.shift();
}

function drawParticles() {
  for (const p of particles) {
    ctx.fillStyle = `rgba(255,200,150,${p.opacity})`;
    ctx.beginPath();
    ctx.arc(p.x, p.y, p.radius, 0, Math.PI * 2);
    ctx.fill();
    p.x -= 2;
    p.radius *= 0.95;
    p.opacity -= 0.02;
  }
}

function emitFireBurst() {
  for (let i = 0; i < 25; i++) {
    fireParticles.push({
      x: dragon.x + dragon.radius * 0.8,
      y: dragon.y - 10 + Math.random() * 20 - 10,
      vx: 4 + Math.random() * 2,
      vy: Math.random() * 2 - 1,
      radius: 4 + Math.random() * 3,
      life: 1,
      hue: 20 + Math.random() * 40
    });
  }
}

function drawFire() {
  for (const p of fireParticles) {
    ctx.fillStyle = `hsla(${p.hue},100%,50%,${p.life})`;
    ctx.beginPath();
    ctx.arc(p.x, p.y, p.radius, 0, Math.PI * 2);
    ctx.fill();
    p.x += p.vx;
    p.y += p.vy;
    p.radius *= 0.96;
    p.life -= 0.03;
  }
}

function drawFireGlow() {
  if (!fireParticles.length) return;
  const gx = dragon.x + dragon.radius * 0.8;
  const gy = dragon.y - 5;
  const active = Math.min(fireParticles.length, 40);
  const radius = 40 + active * 0.5;
  const g = ctx.createRadialGradient(gx, gy, 0, gx, gy, radius);
  g.addColorStop(0, `rgba(255,180,80,${0.3 + Math.random() * 0.2})`);
  g.addColorStop(1, "rgba(255,255,255,0)");
  ctx.save();
  ctx.globalCompositeOperation = "lighter";
  ctx.fillStyle = g;
  ctx.beginPath();
  ctx.arc(gx, gy, radius, 0, Math.PI * 2);
  ctx.fill();
  ctx.restore();
}

function drawDragon() {
  dragon.wingTimer++;
  const flap = Math.sin(dragon.wingTimer * 0.15);
  drawParticles();
  ctx.save();
  ctx.translate(dragon.x, dragon.y);
  const tilt = Math.max(-0.6, Math.min(0.6, (dragon.velocity / 10) + (dragon.vx / 20)));
  ctx.rotate(tilt);

  const grad = ctx.createLinearGradient(-20, -20, 40, 40);
  grad.addColorStop(0, "#ffaaaa");
  grad.addColorStop(1, dragon.color);
  ctx.fillStyle = grad;
  ctx.beginPath();
  ctx.ellipse(0, 0, 30, 20, 0, 0, Math.PI * 2);
  ctx.fill();

  ctx.fillStyle = "rgba(255,255,255,0.4)";
  ctx.beginPath();
  ctx.ellipse(5, 3, 12, 8, 0.1, 0, Math.PI * 2);
  ctx.fill();

  ctx.fillStyle = dragon.color;
  ctx.beginPath();
  ctx.moveTo(-25, 5);
  ctx.lineTo(-55, 0);
  ctx.lineTo(-25, -5);
  ctx.closePath();
  ctx.fill();

  ctx.fillStyle = "#ffb3b3";
  ctx.save();
  ctx.rotate(flap);
  ctx.beginPath();
  ctx.moveTo(0, 0);
  ctx.quadraticCurveTo(-25, -40, -60, -20);
  ctx.quadraticCurveTo(-25, -10, 0, 0);
  ctx.fill();
  ctx.restore();

  ctx.save();
  ctx.rotate(-flap);
  ctx.beginPath();
  ctx.moveTo(0, 0);
  ctx.quadraticCurveTo(25, -40, 60, -20);
  ctx.quadraticCurveTo(25, -10, 0, 0);
  ctx.fill();
  ctx.restore();

  ctx.fillStyle = dragon.color;
  ctx.beginPath();
  ctx.arc(35, -5, 15, 0, Math.PI * 2);
  ctx.fill();

  ctx.fillStyle = "#000";
  ctx.beginPath();
  ctx.arc(40, -8, 3, 0, Math.PI * 2);
  ctx.fill();

  ctx.restore();
}

function rhythmTapBoost(strength = 0.75) {
  const boost = dragon.flapStrength * strength;
  dragon.velocity = boost;
  dragon.y = Math.max(35, dragon.y - 3);
  addParticle();
}

// ************************************************************
// * WIND BACKGROUND
// ************************************************************
const windLines = [];
for (let i = 0; i < 20; i++) {
  windLines.push({
    x: Math.random() * innerWidth,
    y: Math.random() * innerHeight * 0.6 + 50,
    length: 60 + Math.random() * 40,
    speed: 3 + Math.random() * 1.5,
    opacity: 0.15 + Math.random() * 0.1
  });
}

function drawWindLines() {
  ctx.save();
  ctx.strokeStyle = "rgba(255,255,255,0.25)";
  ctx.lineWidth = 2;

  windLines.forEach(w => {
    ctx.globalAlpha = w.opacity;
    ctx.beginPath();
    ctx.moveTo(w.x, w.y);
    ctx.lineTo(w.x + w.length, w.y);
    ctx.stroke();

    w.x -= w.speed;
    if (w.x + w.length < 0) {
      w.x = canvas.width + Math.random() * 300;
      w.y = Math.random() * innerHeight * 0.6 + 50;
      w.opacity = 0.15 + Math.random() * 0.1;
    }
  });

  ctx.restore();
  ctx.globalAlpha = 1;
}

let bubbleStartTime = Date.now();

const stars = [];
function initStars() {
  stars.length = 0;
  for (let i = 0; i < 120; i++) {
    stars.push({
      x: Math.random() * canvas.width,
      y: Math.random() * canvas.height * 0.7,
      r: 1 + Math.random() * 2,
      twinkle: Math.random() * Math.PI * 2
    });
  }
}

function drawStars() {
  for (const s of stars) {
    s.twinkle += 0.05;
    const alpha = 0.5 + Math.sin(s.twinkle) * 0.5;
    ctx.fillStyle = `rgba(255,255,255,${alpha})`;
    ctx.beginPath();
    ctx.arc(s.x, s.y, s.r, 0, Math.PI * 2);
    ctx.fill();
  }
}

function drawRainbow() {
  const cx = canvas.width / 2;
  const cy = canvas.height * 0.85;
  const colors = ["#ff0000", "#ff7f00", "#ffff00", "#00ff00", "#0000ff", "#8b00ff"];

  for (let i = 0; i < colors.length; i++) {
    ctx.beginPath();
    ctx.strokeStyle = colors[i];
    ctx.lineWidth = 30;
    ctx.arc(cx, cy, 300 - i * 25, Math.PI, Math.PI * 2);
    ctx.stroke();
  }
}

function drawSunsetScene() {
  const sunY = 180 + Math.sin(Date.now() / 3000) * 40;
  const sunX = canvas.width / 2;
  const grd = ctx.createRadialGradient(sunX, sunY, 20, sunX, sunY, 120);
  grd.addColorStop(0, "#FFD700");
  grd.addColorStop(1, "rgba(255,150,0,0)");

  ctx.fillStyle = grd;
  ctx.beginPath();
  ctx.arc(sunX, sunY, 120, 0, Math.PI * 2);
  ctx.fill();

  ctx.fillStyle = "#3B945E";
  ctx.beginPath();
  ctx.moveTo(0, canvas.height);
  ctx.quadraticCurveTo(canvas.width * 0.25, canvas.height * 0.7, canvas.width * 0.5, canvas.height);
  ctx.fill();

  ctx.fillStyle = "#256D1B";
  ctx.beginPath();
  ctx.moveTo(canvas.width, canvas.height);
  ctx.quadraticCurveTo(canvas.width * 0.75, canvas.height * 0.7, canvas.width * 0.5, canvas.height);
  ctx.fill();
}

const candySparkles = [];

function drawCandyClouds() {
  const candyColors = ["#ffb3de", "#a3f7bf", "#fff5ba", "#d3adf7", "#ffcccb", "#ffd6a5"];
  const time = Date.now();

  for (let i = 0; i < 7; i++) {
    const baseX = ((time / 25) + i * 180) % (canvas.width + 250) - 250;
    const baseY = 80 + i * 65;
    const color = candyColors[i % candyColors.length];
    const style = i % 3;
    const spin = time / 1000 + i;

    ctx.save();
    ctx.translate(baseX, baseY);
    ctx.rotate(Math.sin(spin * 0.7) * 0.3);

    if (style === 0) {
      const maxRadius = 40 + Math.sin(spin) * 6;
      for (let r = 5; r <= maxRadius; r += 5) {
        const hue = (r * 7 + i * 30) % 360;
        ctx.strokeStyle = `hsl(${hue},80%,70%)`;
        ctx.beginPath();
        ctx.arc(0, 0, r, 0, Math.PI * 2);
        ctx.stroke();
      }
    } else if (style === 1) {
      ctx.fillStyle = color;
      for (let p = 0; p < 6; p++) {
        const angle = (p / 6) * Math.PI * 2;
        const px = Math.cos(angle) * 30;
        const py = Math.sin(angle) * 15;
        ctx.beginPath();
        ctx.ellipse(
          px,
          py,
          28 + Math.sin(spin + p) * 6,
          20 + Math.cos(spin + p) * 4,
          0,
          0,
          Math.PI * 2
        );
        ctx.fill();
      }
    } else {
      ctx.fillStyle = color;
      for (let p = 0; p < 5; p++) {
        const offsetX = Math.cos(spin + p) * 25;
        const offsetY = Math.sin(spin * 0.8 + p) * 18;
        ctx.beginPath();
        ctx.arc(offsetX, offsetY, 26 + Math.sin(spin + p) * 4, 0, Math.PI * 2);
        ctx.fill();
      }
    }

    ctx.restore();
  }

  const now = performance.now();
  if (candySparkles.length < 80) {
    candySparkles.push({
      x: Math.random() * canvas.width,
      y: Math.random() * 120 + 40,
      size: 1 + Math.random() * 2,
      life: now + 800 + Math.random() * 600
    });
  }

  for (let i = candySparkles.length - 1; i >= 0; i--) {
    const s = candySparkles[i];
    const lifeLeft = s.life - now;
    if (lifeLeft <= 0) {
      candySparkles.splice(i, 1);
      continue;
    }
    const flicker = 0.5 + Math.sin(now / 100 + i) * 0.5;
    ctx.fillStyle = `rgba(255,255,255,${flicker})`;
    ctx.beginPath();
    ctx.arc(s.x, s.y, s.size, 0, Math.PI * 2);
    ctx.fill();
  }

  ctx.fillStyle = "rgba(255,255,255,0.9)";
  for (let i = candySparkles.length - 1; i >= 0; i--) {
    const sparkle = candySparkles[i];
    const lifeLeft = (sparkle.life - now) / 600;
    if (lifeLeft <= 0) {
      candySparkles.splice(i, 1);
      continue;
    }
    ctx.globalAlpha = Math.max(0, Math.min(1, lifeLeft));
    ctx.beginPath();
    ctx.arc(sparkle.x, sparkle.y, sparkle.size * (1.2 - lifeLeft * 0.5), 0, Math.PI * 2);
    ctx.fill();
  }

  ctx.globalAlpha = 1;
}
/************************************************************
 * BABY BUDDIES
 ************************************************************/
const babyPalette=["#ff7675","#ff9ff3","#74b9ff","#ffeaa7","#a29bfe"];
const babyFireBursts=[];
function resetRescueState(){
  babyDragons=[];
  rescuedCount=0;
  rescueSlotQueue=[];
}
function getSlotPosition(index){
  const offset=podSlotOffsets[index]||{x:0,y:0};
  return {
    x:rescuePod.x+offset.x*rescuePod.radius,
    y:rescuePod.y+offset.y*rescuePod.radius
  };
}
function generateBabyDragons(count) {
  const arr = [];

  for (let i = 0; i < count; i++) {
    let x;
    let y;
    let tries = 0;
    const padding = 120;

    do {
      x = padding + Math.random() * (canvas.width - padding * 2);
      y = padding + Math.random() * (canvas.height - padding * 2);
      tries++;
    } while (distanceToPod(x, y) < rescuePod.radius * 1.3 && tries < 40);

    arr.push({
      x,
      y,
      baseY: y,
      scale: 0.42 + Math.random() * 0.08,
      color: babyPalette[i % babyPalette.length],
      state: "waiting",
      waveOffset: Math.random() * Math.PI * 2,
      slotIndex: null
    });
  }

  return arr;
}

function distanceToPod(x,y){
  return Math.hypot(x-rescuePod.x,y-rescuePod.y);
}
function updateBabyDragons() {
  babyDragons.forEach(baby => {
    if (baby.state === "waiting") {
      baby.waveOffset += 0.02;
      baby.y = baby.baseY + Math.sin(baby.waveOffset) * 10;
    } else if (baby.state === "flying") {
      const target = getSlotPosition(baby.slotIndex);
      baby.x += (target.x - baby.x) * 0.1;
      baby.y += (target.y - baby.y) * 0.1;

      if (Math.hypot(target.x - baby.x, target.y - baby.y) < 1.5) {
        baby.state = "stored";
        baby.x = target.x;
        baby.y = target.y;
      }
    }
  });

  rescuePod.glowPhase += 0.02;
}

function drawRescuePodBack() {
  ctx.save();
  ctx.translate(rescuePod.x, rescuePod.y);
  const r = rescuePod.radius;

  ctx.fillStyle = "rgba(10,20,40,0.35)";
  ctx.beginPath();
  ctx.arc(0, 0, r * 1.1, 0, Math.PI * 2);
  ctx.fill();

  const baseGrad = ctx.createLinearGradient(0, -r, 0, r);
  baseGrad.addColorStop(0, "rgba(255,255,255,0.08)");
  baseGrad.addColorStop(1, "rgba(120,160,220,0.15)");
  ctx.fillStyle = baseGrad;
  ctx.beginPath();
  ctx.arc(0, 0, r, 0, Math.PI * 2);
  ctx.fill();

  ctx.fillStyle = "rgba(255,255,255,0.25)";
  ctx.beginPath();
  ctx.ellipse(0, r * 0.82, r * 0.75, r * 0.2, 0, 0, Math.PI * 2);
  ctx.fill();
  ctx.restore();
}

function drawRescueSlotGuides() {
  podSlotOffsets.forEach((offset, idx) => {
    const pos = getSlotPosition(idx);
    const slotFilled = babyDragons.some(
      baby => baby.slotIndex === idx && (baby.state === "stored" || baby.state === "flying")
    );
    if (slotFilled) return;

    ctx.fillStyle = "rgba(255,255,255,0.15)";
    ctx.beginPath();
    ctx.arc(pos.x, pos.y, 18, 0, Math.PI * 2);
    ctx.fill();
  });
}
function drawBabyPerch(b){
  ctx.fillStyle="rgba(255,255,255,0.8)";
  ctx.beginPath();
  ctx.ellipse(b.x,b.baseY+30,40,16,0,0,Math.PI*2);
  ctx.fill();
}
function drawChibiDragon(b){
  ctx.save();
  ctx.translate(b.x,b.y);
  const scale=b.scale;
  ctx.scale(scale,scale);
  ctx.fillStyle=b.color;
  ctx.beginPath();
  ctx.ellipse(0,0,40,28,0,0,Math.PI*2);
  ctx.fill();

  ctx.fillStyle="rgba(255,255,255,0.45)";
  ctx.beginPath();
  ctx.ellipse(5,5,18,14,0,0,Math.PI*2);
  ctx.fill();

  ctx.fillStyle=b.color;
  ctx.save();
  const wave=Math.sin(Date.now()/200+b.waveOffset)*0.2;
  ctx.rotate(wave);
  ctx.beginPath();
  ctx.moveTo(-5,0);
  ctx.quadraticCurveTo(-30,-35,-65,-15);
  ctx.quadraticCurveTo(-35,-5,-5,0);
  ctx.fill();
  ctx.restore();

  ctx.fillStyle=b.color;
  ctx.beginPath();
  ctx.moveTo(-5,0);
  ctx.quadraticCurveTo(-30,35,-65,15);
  ctx.quadraticCurveTo(-35,5,-5,0);
  ctx.fill();

  ctx.fillStyle=b.color;
  ctx.beginPath();
  ctx.arc(32,-4,12,0,Math.PI*2);
  ctx.fill();

  ctx.fillStyle="#000";
  ctx.beginPath();
  ctx.arc(35,-6,3,0,Math.PI*2);
  ctx.fill();

  ctx.restore();
}
function drawBabyDragons(){
  babyDragons.forEach(b=>{
    if(b.state==="waiting")drawBabyPerch(b);
    drawChibiDragon(b);
  });
}
function drawBabyFireBursts(){
  if(!babyFireBursts.length)return;
  for(let i=babyFireBursts.length-1;i>=0;i--){
    const f=babyFireBursts[i];
    f.x+=Math.cos(f.angle)*f.speed;
    f.y+=Math.sin(f.angle)*f.speed;
    f.life-=0.03;
    ctx.fillStyle=`hsla(${f.hue},100%,60%,${f.life})`;
    ctx.beginPath();
    ctx.ellipse(f.x,f.y,4,4,0,0,Math.PI*2);
    ctx.fill();
    if(f.life<=0)babyFireBursts.splice(i,1);
  }
}
function drawRescuePodFront() {
  const level = levels[currentLevel];

  ctx.save();
  ctx.translate(rescuePod.x, rescuePod.y);
  const r = rescuePod.radius;
  const glow = 0.35 + Math.sin(rescuePod.glowPhase) * 0.1;
  const glass = ctx.createRadialGradient(-r * 0.2, -r * 0.35, r * 0.2, 0, 0, r);
  glass.addColorStop(0, `rgba(255,255,255,${0.7 + glow * 0.3})`);
  glass.addColorStop(0.55, "rgba(200,230,255,0.25)");
  glass.addColorStop(1, "rgba(255,255,255,0.08)");
  ctx.fillStyle = glass;
  ctx.beginPath();
  ctx.arc(0, 0, r, 0, Math.PI * 2);
  ctx.fill();

  ctx.lineWidth = 6;
  ctx.strokeStyle = `rgba(255,255,255,${0.4 + glow * 0.2})`;
  ctx.beginPath();
  ctx.arc(0, 0, r, 0, Math.PI * 2);
  ctx.stroke();

  ctx.strokeStyle = "rgba(255,255,255,0.35)";
  ctx.lineWidth = 4;
  ctx.beginPath();
  ctx.arc(-r * 0.2, -r * 0.25, r * 0.6, Math.PI * 1.1, Math.PI * 1.7);
  ctx.stroke();
  ctx.restore();

  if (level && isMathBubbleLevel(level)) {
    drawMathBubbleEquation(level);
  }
}
function drawMathBubbleEquation(level) {
  if (!level || !isMathBubbleLevel(level)) return;

  const stageCount =
    typeof level.mathBubbleStage === "number"
      ? level.mathBubbleStage
      : mathBubbleStage;

  const fullEquation = level.mathEquation || currentMathEquation || "1 + 1 = 2";
  const tokens = mathBubbleTokens.length
    ? mathBubbleTokens
    : fullEquation.split(/\s+/).filter(Boolean);

  const clampedStage = Math.max(0, Math.min(stageCount, tokens.length));
  if (clampedStage === 0) return;

  const text =
    clampedStage >= tokens.length
      ? tokens.join(" ")
      : tokens.slice(0, clampedStage).join(" ");

  const fontSize = Math.max(24, rescuePod.radius * 0.32);
  const paddingX = 20;
  const paddingY = 12;

  ctx.save();

  if (typeof ctx.resetTransform === "function") {
    ctx.resetTransform();
  } else {
    ctx.setTransform(1, 0, 0, 1, 0, 0);
  }

  ctx.font = `bold ${fontSize}px "Comic Sans MS", "Comic Neue", cursive`;
  ctx.textAlign = "center";
  ctx.textBaseline = "middle";

  const metrics = ctx.measureText(text);
  const textHeight =
    (metrics.actualBoundingBoxAscent || fontSize * 0.7) +
    (metrics.actualBoundingBoxDescent || fontSize * 0.3);
  const boxWidth = metrics.width + paddingX * 2;
  const boxHeight = textHeight + paddingY * 2;

  const centerX = canvas.width / 2;
  const centerY = canvas.height / 2;
  const boxX = centerX - boxWidth / 2;
  const boxY = centerY - boxHeight / 2;

  ctx.fillStyle = "rgba(255,255,255,0.95)";
  ctx.strokeStyle = "rgba(0,0,0,0.18)";
  ctx.lineWidth = 2;

  if (typeof ctx.roundRect === "function") {
    ctx.beginPath();
    ctx.roundRect(boxX, boxY, boxWidth, boxHeight, 16);
    ctx.fill();
    ctx.stroke();
  } else {
    ctx.fillRect(boxX, boxY, boxWidth, boxHeight);
    ctx.strokeRect(boxX, boxY, boxWidth, boxHeight);
  }

  ctx.fillStyle = "#2c3e50";
  ctx.fillText(text, centerX, centerY);

  ctx.restore();
}
function spawnBabyFire(x, y) {
  for (let i = 0; i < 22; i++) {
    babyFireBursts.push({
      x,
      y,
      angle: (Math.random() * 0.8 - 0.4) + Math.PI * 0.05,
      speed: 2 + Math.random() * 2,
      life: 1,
      hue: 20 + Math.random() * 40
    });
  }
}

/************************************************************
 * RHYTHM VISUALS
 ************************************************************/
function drawDualLaneRhythm(now) {
  const cfg = rhythmState.config;
  const laneXs = {
    left: getDualLaneX("left"),
    right: getDualLaneX("right")
  };
  const hitLineY = canvas.height * 0.8;
  const laneWidth = canvas.width * 0.16;
  const laneTop = canvas.height * 0.08;
  const laneBottom = canvas.height * 0.88;

  ctx.save();
  Object.entries(laneXs).forEach(([lane, x]) => {
    const gradient = ctx.createLinearGradient(
      x - laneWidth / 2,
      laneTop,
      x + laneWidth / 2,
      laneTop
    );
    gradient.addColorStop(0, "rgba(255,255,255,0)");
    gradient.addColorStop(
      0.45,
      lane === "left" ? "rgba(121,195,255,0.05)" : "rgba(255,170,239,0.05)"
    );
    gradient.addColorStop(
      0.5,
      lane === "left" ? "rgba(121,195,255,0.12)" : "rgba(255,170,239,0.12)"
    );
    gradient.addColorStop(1, "rgba(255,255,255,0)");
    ctx.fillStyle = gradient;
    ctx.fillRect(x - laneWidth / 2, laneTop, laneWidth, laneBottom - laneTop);
  });
  ctx.restore();

  ctx.save();
  ctx.strokeStyle="rgba(255,255,255,0.08)";
  ctx.lineWidth=2;
  ctx.setLineDash([8,10]);
  Object.values(laneXs).forEach(x=>{
    ctx.beginPath();
    ctx.moveTo(x,0);
    ctx.lineTo(x,canvas.height);
    ctx.stroke();
  });
  ctx.setLineDash([]);
  ctx.restore();

  ctx.strokeStyle="rgba(255,255,255,0.25)";
  ctx.lineWidth=4;
  ctx.beginPath();
  ctx.moveTo(canvas.width*0.18,hitLineY);
  ctx.lineTo(canvas.width*0.82,hitLineY);
  ctx.stroke();

  rhythmState.activeNotes.forEach(note=>{
    const x=laneXs[note.lane]||canvas.width/2;
    const y=typeof note.y==="number"?note.y:canvas.height*0.2;
    const progress=Math.max(0,Math.min(1,note.progress||0));
    const radius=26*(0.65+0.35*progress);
    const noteTime=rhythmState.sequenceStart+note.time;
    const timeUntilHit=noteTime-now;
    const approach=Math.max(0,Math.min(1,1-(timeUntilHit/cfg.leadTime)));
    const life=note.hit
      ? Math.max(0,1-((now-note.hitTime)/350))
      : 0.25+0.75*progress;
    const missFade=note.result==="miss"
      ? Math.max(0,1-((now-note.hitTime)/260))
      : 1;
    const opacity=Math.max(0,Math.min(1,life*missFade));
    if(opacity<=0)return;

    if(!note.hit){
      ctx.save();
      ctx.strokeStyle=`rgba(255,255,255,${0.15+0.4*approach})`;
      ctx.lineWidth=4;
      ctx.beginPath();
      ctx.moveTo(x,hitLineY);
      ctx.lineTo(x,y);
      ctx.stroke();
      ctx.restore();
    }

    ctx.save();
    ctx.globalAlpha=opacity;
    const urgency=Math.max(0,1-Math.min(1,Math.abs(timeUntilHit)/cfg.windowGood));
    if(!note.hit){
      ctx.strokeStyle=`rgba(255,255,255,${0.18+0.45*urgency})`;
      ctx.lineWidth=2.5;
      ctx.beginPath();
      ctx.arc(x,hitLineY,radius*(1.2+urgency*0.4),0,Math.PI*2);
      ctx.stroke();
    }

    const gradient=ctx.createRadialGradient(
      x-radius*0.35,
      y-radius*0.35,
      radius*0.2,
      x,
      y,
      radius*1.4
    );
    if(note.result==="miss"){
      gradient.addColorStop(0,"rgba(255,122,133,0.9)");
      gradient.addColorStop(1,"rgba(255,255,255,0.05)");
    }else if(note.hit && note.result==="perfect"){
      gradient.addColorStop(0,"rgba(137,255,222,0.9)");
      gradient.addColorStop(1,"rgba(255,255,255,0.08)");
    }else if(note.hit && note.result==="good"){
      gradient.addColorStop(0,"rgba(255,212,121,0.9)");
      gradient.addColorStop(1,"rgba(255,255,255,0.08)");
    }else{
      gradient.addColorStop(0,note.lane==="left"?"#c4e6ff":"#ffd4f6");
      gradient.addColorStop(1,"rgba(255,255,255,0.08)");
    }
    ctx.fillStyle=gradient;
    ctx.beginPath();
    ctx.ellipse(x,y,radius*1.25,radius,0,0,Math.PI*2);
    ctx.fill();

    const ringProgress=Math.max(0,Math.min(1,1-(timeUntilHit/cfg.leadTime)));
    if(!note.hit||note.result==="miss"){
      ctx.strokeStyle=`rgba(255,255,255,${0.14+0.3*ringProgress})`;
      ctx.lineWidth=2;
      ctx.beginPath();
      ctx.arc(x,y,radius*(1.35+(1-ringProgress)),0,Math.PI*2);
      ctx.stroke();
    }

    if(note.hit){
      const fade=Math.max(0,1-((now-note.hitTime)/360));
      if(fade>0){
        ctx.save();
        ctx.globalCompositeOperation="lighter";
        const glowColor=note.result==="perfect"
          ?"rgba(137,255,222,0.7)"
          :note.result==="good"
            ?"rgba(255,212,121,0.6)"
            :"rgba(255,122,133,0.55)";
        ctx.fillStyle=glowColor;
        ctx.globalAlpha=fade*0.8;
        ctx.beginPath();
        ctx.arc(x,y,radius*1.9,0,Math.PI*2);
        ctx.fill();
        ctx.restore();
      }
    }
    ctx.restore();
  });
}
function drawRhythmClouds(now){
  if(!rhythmState.active)return;
  if(rhythmState.mode==="dualLane"){
    drawDualLaneRhythm(now);
    return;
  }
  const cfg=rhythmState.config;
  rhythmState.clouds.forEach(cloud=>{
    const timeToBeat=cloud.beatTime-now;
    if(timeToBeat>cfg.preDisplay)return;
    const timeSinceBeat=now-cloud.beatTime;
    const settleWindow=cloud.state==="pending"
      ?cfg.preDisplay
      :(cloud.state==="hit"?cfg.windowGood+700:cfg.windowGood+450);
    if(timeSinceBeat>settleWindow && cloud.state!=="pending")return;

    const pos=getCloudPosition(cloud);
    ctx.save();
    ctx.translate(pos.x,pos.y);
    const pulse=1+Math.sin((now+cloud.index*220)/600)*0.03;
    const settleScale=getCloudSettleScale(cloud,timeSinceBeat);
    ctx.scale(pulse+settleScale,pulse+settleScale);
    const opacity=getCloudOpacity(cloud,timeToBeat,timeSinceBeat,cfg);
    ctx.globalAlpha=opacity;
    drawTimingRing(cloud,timeToBeat,cfg);
    drawFluffyCloud(cloud);
    ctx.restore();
  });
}
function getCloudSettleScale(cloud,timeSinceBeat){
  if(cloud.state==="hit"){
    return Math.min(0.3,timeSinceBeat/900);
  }
  if(cloud.state==="missed"){
    return -Math.min(0.25,timeSinceBeat/600);
  }
  return 0;
}
function getCloudOpacity(cloud,timeToBeat,timeSinceBeat,cfg){
  if(cloud.state==="pending"){
    if(timeToBeat>0){
      const appear=1-(timeToBeat/cfg.preDisplay);
      return 0.35+appear*0.65;
    }
    return 1;
  }
  const linger=cloud.state==="hit"?700:450;
  const fadeStart=Math.max(0,cfg.windowGood*0.6);
  if(timeSinceBeat<=fadeStart){
    return 1;
  }
  const elapsed=timeSinceBeat-fadeStart;
  return Math.max(0,1-(elapsed/linger));
}
function drawTimingRing(cloud,timeToBeat,cfg){
  if(cloud.state==="hit")return;
  if(timeToBeat<-cfg.windowGood)return;
  ctx.save();
  const normalized=Math.max(0,Math.min(1,(timeToBeat+cfg.preDisplay)/cfg.preDisplay));
  const ringRadius=cloud.radius+5+(1-normalized)*35;
  ctx.strokeStyle="rgba(255,255,255,0.75)";
  ctx.lineWidth=4;
  ctx.beginPath();
  ctx.arc(0,0,Math.max(cloud.radius+4,ringRadius),0,Math.PI*2);
  ctx.stroke();

  if(Math.abs(timeToBeat)<=cfg.windowGood){
    ctx.strokeStyle="rgba(255,255,255,0.4)";
    ctx.setLineDash([8,6]);
    ctx.beginPath();
    ctx.arc(0,0,cloud.radius+10,0,Math.PI*2);
    ctx.stroke();
    ctx.setLineDash([]);
  }
  ctx.restore();
}
function drawFluffyCloud(cloud){
  const colors={
    pending:"rgba(255,255,255,0.9)",
    hit:cloud.hitQuality==="perfect"?"rgba(255,224,102,0.95)":"rgba(155,89,182,0.9)",
    missed:"rgba(255,255,255,0.35)"
  };
  ctx.fillStyle=colors[cloud.state]||colors.pending;
  ctx.beginPath();
  ctx.ellipse(-cloud.radius*0.4,0,cloud.radius*0.7,cloud.radius*0.55,0,0,Math.PI*2);
  ctx.ellipse(cloud.radius*0.15,0,cloud.radius*0.65,cloud.radius*0.5,0,0,Math.PI*2);
  ctx.ellipse(0,-cloud.radius*0.35,cloud.radius*0.5,cloud.radius*0.45,0,0,Math.PI*2);
  ctx.fill();

  ctx.fillStyle="rgba(255,255,255,0.6)";
  ctx.beginPath();
  ctx.ellipse(-cloud.radius*0.1,-cloud.radius*0.25,cloud.radius*0.3,cloud.radius*0.2,0,0,Math.PI*2);
  ctx.fill();

  if(cloud.state==="hit"){
    ctx.save();
    ctx.globalCompositeOperation="lighter";
    ctx.fillStyle=cloud.hitQuality==="perfect"
      ?"rgba(255,224,102,0.55)"
      :"rgba(155,89,182,0.45)";
    ctx.beginPath();
    ctx.arc(0,0,cloud.radius*1.8,0,Math.PI*2);
    ctx.fill();
    ctx.restore();
  }else if(cloud.state==="pending"){
    ctx.fillStyle="#2d3436";
    ctx.beginPath();
    ctx.arc(-cloud.radius*0.15,-cloud.radius*0.05,4,0,Math.PI*2);
    ctx.arc(cloud.radius*0.15,-cloud.radius*0.05,4,0,Math.PI*2);
    ctx.fill();
  }else if(cloud.state==="missed"){
    ctx.strokeStyle="rgba(255,150,150,0.8)";
    ctx.lineWidth=3;
    ctx.beginPath();
    ctx.moveTo(-cloud.radius*0.35,-cloud.radius*0.18);
    ctx.lineTo(cloud.radius*0.35,cloud.radius*0.18);
    ctx.moveTo(-cloud.radius*0.35,cloud.radius*0.18);
    ctx.lineTo(cloud.radius*0.35,-cloud.radius*0.18);
    ctx.stroke();
  }

  if(cloud.state==="hit"){
    ctx.fillStyle="rgba(255,255,255,0.7)";
    ctx.beginPath();
    ctx.arc(0,0,10,0,Math.PI*2);
    ctx.fill();
  }
}
/************************************************************
 * OBJECT DRAW + POP TEXT
 ************************************************************/
const popTexts = [];

/* --- suppress pop-text overlays on specific levels --- */
const suppressedPopLevels = new Set([9]); // Add 10 later (e.g., new Set([9, 10]))
function shouldSuppressPopText(levelIndex = currentLevel) {
  const levelNumber = levels[levelIndex]?.levelNumber ?? levelIndex + 1;
  return suppressedPopLevels.has(levelNumber);
}
const originalPopTextsPush = popTexts.push.bind(popTexts);
popTexts.push = function (...items) {
  if (shouldSuppressPopText()) {
    return popTexts.length;
  }
  return originalPopTextsPush(...items);
};
/************************************************************
 * OBJECT TYPES
 ************************************************************/
const objectTypes = {
  balloon: {
    id: "balloon",
    shape: "circle",
    color: "#ff7675",
    score: +20
  },
  star: {
    id: "star",
    shape: "star",
    color: "#ffe066",
    score: +25
  },
  gem: {
    id: "gem",
    shape: "diamond",
    color: "#74b9ff",
    score: +30
  },
  heart: {
    id: "heart",
    shape: "heart",
    color: "#ff6b81",
    score: -25
  },
  coin: {
    id: "coin",
    shape: "coin",
    color: "#f1c40f",
    score: +10,
    coinValue: 1
  }
};
function chooseObjectType(level) {
  // üõ°Ô∏è Guard against undefined level objects
  if (!level || typeof level !== "object" || !("mechanic" in level)) {
    console.warn("chooseObjectType() called with invalid or missing level; using balloon fallback.");
    return objectTypes.balloon;
  }

  if (level.mechanic === "coinGoal" && Math.random() < 0.7) {
    return objectTypes.coin;
  }
  const keys = Object.keys(objectTypes);
  const randomKey = keys[Math.floor(Math.random() * keys.length)];
  return objectTypes[randomKey];
}

function drawShape(shape, radius) {
  ctx.beginPath();
  switch (shape) {
    case "circle":
      ctx.arc(0, 0, radius, 0, Math.PI * 2);
      break;
    case "diamond":
      ctx.moveTo(0, -radius);
      ctx.lineTo(radius, 0);
      ctx.lineTo(0, radius);
      ctx.lineTo(-radius, 0);
      ctx.closePath();
      break;
    case "star":
      for (let i = 0; i < 5; i++) {
        const angle = (Math.PI * 2 * i) / 5 - Math.PI / 2;
        ctx.lineTo(Math.cos(angle) * radius, Math.sin(angle) * radius);
        ctx.lineTo(
          Math.cos(angle + Math.PI / 5) * radius * 0.5,
          Math.sin(angle + Math.PI / 5) * radius * 0.5
        );
      }
      ctx.closePath();
      break;
    case "heart":
      ctx.moveTo(0, -radius / 2);
      ctx.bezierCurveTo(radius, -radius, radius, radius / 3, 0, radius);
      ctx.bezierCurveTo(-radius, radius / 3, -radius, -radius, 0, -radius / 2);
      break;
    case "coin":
      drawCoinGraphic(radius);
      return;
    default:
      ctx.arc(0, 0, radius, 0, Math.PI * 2);
  }
}

function drawCoinGraphic(radius) {
  const base = ctx.createRadialGradient(
    -radius * 0.3,
    -radius * 0.3,
    radius * 0.2,
    0,
    0,
    radius
  );
  base.addColorStop(0, "#fff9c4");
  base.addColorStop(0.45, "#fdd835");
  base.addColorStop(1, "#c88719");
  ctx.fillStyle = base;
  ctx.beginPath();
  ctx.arc(0, 0, radius, 0, Math.PI * 2);
  ctx.fill();

  ctx.lineWidth = 4;
  ctx.strokeStyle = "rgba(255,255,255,0.65)";
  ctx.beginPath();
  ctx.arc(0, 0, radius * 0.82, 0, Math.PI * 2);
  ctx.stroke();

  const shine = ctx.createRadialGradient(
    -radius * 0.4,
    -radius * 0.45,
    0,
    0,
    0,
    radius * 0.9
  );
  shine.addColorStop(0, "rgba(255,255,255,0.8)");
  shine.addColorStop(0.4, "rgba(255,255,255,0.15)");
  shine.addColorStop(1, "rgba(255,255,255,0)");
  ctx.fillStyle = shine;
  ctx.beginPath();
  ctx.arc(0, 0, radius, 0, Math.PI * 2);
  ctx.fill();

  ctx.strokeStyle = "#fff6d5";
  ctx.lineWidth = 3;
  ctx.lineCap = "round";
  ctx.beginPath();
  ctx.moveTo(0, -radius * 0.55);
  ctx.bezierCurveTo(
    radius * 0.4,
    -radius * 0.55,
    radius * 0.4,
    -radius * 0.1,
    0,
    -radius * 0.15
  );
  ctx.bezierCurveTo(
    -radius * 0.4,
    -radius * 0.1,
    -radius * 0.4,
    radius * 0.35,
    0,
    radius * 0.35
  );
  ctx.bezierCurveTo(
    radius * 0.35,
    radius * 0.35,
    radius * 0.35,
    radius * 0.65,
    0,
    radius * 0.65
  );
  ctx.stroke();

  ctx.beginPath();
  ctx.moveTo(0, -radius * 0.7);
  ctx.lineTo(0, radius * 0.7);
  ctx.stroke();

  ctx.save();
  ctx.rotate(-Math.PI / 6);
  ctx.strokeStyle = "rgba(255,255,255,0.7)";
  ctx.lineWidth = 2;
  ctx.beginPath();
  ctx.moveTo(radius * 0.45, 0);
  ctx.lineTo(radius * 0.62, 0);
  ctx.moveTo(radius * 0.53, -radius * 0.08);
  ctx.lineTo(radius * 0.52, radius * 0.08);
  ctx.stroke();
  ctx.restore();
}

function drawObjects() {
  if (isRescueLevel() || isRhythmLevel()) return;

  const levelSpeed = [1.5, 1.2, 1.3, 1.4][currentLevel] || 1.5;

  objects.forEach(obj => {
    const type = obj.type;

    ctx.save();
    ctx.translate(obj.x, obj.y);

    if (type.shape === "coin") {
      const wobble = Math.sin(Date.now() / 250 + obj.x * 0.01) * 0.15;
      const pulse = 1 + Math.sin(Date.now() / 300 + obj.y * 0.02) * 0.08;
      ctx.rotate(wobble);
      ctx.scale(pulse, 1);
      drawCoinGraphic(obj.radius);
    } else {
      ctx.fillStyle = type.color || "#ffffff";
      drawShape(type.shape, obj.radius);
      ctx.fill();

      ctx.font = "bold 18px 'Comic Sans MS', sans-serif";
      ctx.fillStyle = type.score >= 0 ? "#ffffff" : "#ffaaaa";
      ctx.textAlign = "center";
      ctx.textBaseline = "middle";
      ctx.fillText(
        `${type.score > 0 ? "+" : ""}${type.score}`,
        0,
        0
      );
    }

    ctx.restore();

    obj.x -= levelSpeed;
    obj.y += Math.sin(Date.now() / 300 + obj.x / 50) * 0.5;

    if (obj.x + obj.radius < 0) {
      respawnObject(obj);
    }
  });
}

function renderAlphabetLetters(context) {
  if (!alphabetState.active) return;

  for (const node of alphabetState.letters) {
    if (!node) continue;

    context.save();
    context.translate(node.x, node.y);

    const radius = node.radius ?? 36;
    const baseColor = node.color ?? "#f97316";
    const gradient = context.createRadialGradient(0, 0, radius * 0.2, 0, 0, radius);

    if (node.active) {
      gradient.addColorStop(0, "rgba(255, 255, 255, 0.95)");
      gradient.addColorStop(1, baseColor);
    } else {
      gradient.addColorStop(0, "rgba(200, 200, 200, 0.6)");
      gradient.addColorStop(1, "rgba(130, 130, 130, 0.45)");
    }

    context.fillStyle = gradient;
    context.beginPath();
    context.arc(0, 0, radius, 0, Math.PI * 2);
    context.fill();

    context.strokeStyle = node.active
      ? "rgba(255, 255, 255, 0.95)"
      : "rgba(210, 210, 210, 0.35)";
    context.lineWidth = 3;
    context.stroke();

    context.fillStyle = node.active ? "#1f2933" : "#4b5563";
    context.font = `${Math.floor(radius * 0.9)}px 'Fredoka One', sans-serif`;
    context.textAlign = "center";
    context.textBaseline = "middle";
    context.fillText(node.letter ?? "", 0, 3);

    context.restore();
  }
}
function renderNumberNodes(context) {
  if (!numberState.active) return;

  const now = performance.now();

  for (const node of numberState.nodes) {
    if (!node) continue;

    context.save();
    context.translate(node.x, node.y);

    const radius = node.radius ?? numberState.bubbleRadius ?? 44;
    const pulse = 1 + Math.sin((now / 300) + (node.pulseOffset || 0)) * 0.04;
    const actualRadius = radius * pulse;

    const baseColor = node.color ?? "#fde68a";
    const gradient = context.createRadialGradient(0, 0, actualRadius * 0.2, 0, 0, actualRadius);
    if (node.active) {
      gradient.addColorStop(0, "rgba(255,255,255,0.95)");
      gradient.addColorStop(1, baseColor);
    } else {
      gradient.addColorStop(0, "rgba(200,200,200,0.6)");
      gradient.addColorStop(1, "rgba(130,130,130,0.45)");
    }

    context.fillStyle = gradient;
    context.beginPath();
    context.arc(0, 0, actualRadius, 0, Math.PI * 2);
    context.fill();

    context.strokeStyle = node.active
      ? "rgba(255,255,255,0.95)"
      : "rgba(210,210,210,0.35)";
    context.lineWidth = 3;
    context.stroke();

    context.fillStyle = node.active ? "#1f2933" : "#4b5563";
    context.font = `${Math.floor(actualRadius * 0.85)}px 'Fredoka One', sans-serif`;
    context.textAlign = "center";
    context.textBaseline = "middle";
    context.fillText(node.value ?? "", 0, 4);

    context.restore();
  }
}

function drawPopTexts() {
  for (let i = popTexts.length - 1; i >= 0; i--) {
    const p = popTexts[i];
    ctx.font = "20px Comic Sans MS";
    ctx.fillStyle = p.color;
    ctx.globalAlpha = p.life;
    ctx.fillText(p.text, p.x, p.y);
    ctx.globalAlpha = 1;

    p.y -= 1;
    p.life -= 0.02;

    if (p.life <= 0) {
      popTexts.splice(i, 1);
    }
  }
}
/************************************************************
 * LEVEL PROGRESSION
 ************************************************************/
const campaignState = {
  bestLevel: 0,
  runsCompleted: 0
};

function handleCampaignComplete() {
  campaignState.runsCompleted += 1;

  const totalLevels = Array.isArray(levels) ? levels.length : 0;

  winOverlay.innerHTML = "";
  winOverlay.style.display = "block";

  const title = document.createElement("div");
  title.textContent = "YOU WIN!";
  title.style.fontSize = "28px";
  title.style.fontWeight = "700";
  title.style.marginBottom = "12px";

  const details = document.createElement("div");
  details.style.fontSize = "20px";
  details.textContent = `Cleared all ${totalLevels} levels! Tap to start over.`;

  winOverlay.appendChild(title);
  winOverlay.appendChild(details);
}

function levelComplete() {
  if (levelEnding) return;
  levelEnding = true;

  // Clear any active timers
  if (window._levelTimer) {
    clearTimeout(window._levelTimer);
    window._levelTimer = null;
  }

  // ‚úÖ Success sound
  playTone(880, 0.15, "sine", 0.25);

  // ‚úÖ Ensure currentLevel is numeric
  currentLevel = parseInt(currentLevel, 10) || 0;

  // Level info and progression
  const L = levels[currentLevel] || {};
  const isFinalLevel = currentLevel >= levels.length - 1;

  // ‚úÖ Overlay setup
  winOverlay.innerHTML = "";
  winOverlay.style.display = "block";
  winOverlay.style.cursor = "default";

  const title = document.createElement("div");
  title.style.fontSize = "32px";
  title.style.fontWeight = "700";
  title.style.marginBottom = "10px";
  title.style.color = "#27ae60";

  const info = document.createElement("div");
  info.style.fontSize = "24px";
  info.style.color = "#333";

  // ‚úÖ Winner message
  const nextLevelNumber = currentLevel + 2;
  title.textContent = `üèÜ Winner!  Now on to Level ${nextLevelNumber}`;
  info.textContent = "";

  winOverlay.appendChild(title);
  winOverlay.appendChild(info);

  // --- Campaign complete check ---
  if (isFinalLevel) {
    handleCampaignComplete();
    levelEnding = false;
    return;
  }

  // ‚úÖ Timer to hide overlay and move on
  window._levelTimer = setTimeout(() => {
    // üß© DEBUG: confirm timer and currentLevel before advancing
    console.log("‚è∞ Level timer firing, currentLevel =", currentLevel, "levels.length =", levels.length);

    // Compute next index safely based on current global level
    currentLevel = Number(currentLevel) || 0;
    const nextIndex = currentLevel + 1;

    console.log("‚è∞ Level timer firing, loading next index:", nextIndex);
    console.log("‚û°Ô∏è About to call loadLevel, currentLevel:", currentLevel, "nextIndex:", nextIndex, "levels[nextIndex]:", !!levels[nextIndex]);

    // Hide winner overlay and reset flags
    winOverlay.style.display = "none";
    levelEnding = false;
    window._levelTimer = null;

    // ‚úÖ Advance the global index before loading
    currentLevel = nextIndex;

    // ‚úÖ Safely load next level (restores Skip Intro compatibility)
    if (typeof loadLevel === "function" && levels[nextIndex]) {
      loadLevel(currentLevel);
    } else if (window.loadLevel && levels[nextIndex]) {
      window.loadLevel(currentLevel);
    } else {
      console.warn("‚ö†Ô∏è Unable to load next level:", nextIndex);
    }
  }, 3000);
}

/************************************************************
 * POP VISUALS + SOUND HELPERS (Fixes broken popping feedback)
 ************************************************************/
function playPopSound() {
  // Reuse the global tone synthesizer to make cheerful pops
  try {
    playTone(880 + Math.random() * 220, 0.12, "square", 0.25);
  } catch (e) {
    console.warn("Pop sound failed:", e);
  }
}

function spawnPopEffect(x, y) {
  // Simple burst of small fire particles when a balloon pops
  for (let i = 0; i < 15; i++) {
    fireParticles.push({
      x: x + (Math.random() - 0.5) * 18,
      y: y + (Math.random() - 0.5) * 18,
      vx: Math.random() * 3 - 1.5,
      vy: Math.random() * 3 - 1.5,
      radius: 2 + Math.random() * 3,
      life: 1,
      hue: 15 + Math.random() * 60
    });
  }
}
/************************************************************
 * HIT DETECTION
 ************************************************************/
function detectHits() {
  // ‚úÖ make sure we pull the real level object, not just the index
  const L = levels[currentLevel];
  console.log("DetectHits running,", L?.name, "Objects:", objects.length);
  if (!L) return;

  // ‚úÖ Rescue and rhythm levels use their own detectors
  if (L.mechanic === "rescueGoal" || L.mechanic === "rhythmBounce") {
    if (L.mechanic === "rescueGoal") detectRescueHits(L);
    return;
  }

  // ‚úÖ wait until flight actually starts
  if (L.control === "flap" && !flightStarted) return;
  if (levelEnding) return;

  for (const obj of objects) {
    const dx = dragon.x - obj.x;
    const dy = dragon.y - obj.y;
    const dist = Math.sqrt(dx * dx + dy * dy);
    const hitRange = (dragon.radius + obj.radius) * 1.3;

    if (dist >= hitRange) continue; // no collision

    // --- COIN GOAL ---
    if (L.mechanic === "coinGoal" && obj.type.id === "coin") {
      const coinValue = obj.type.coinValue || L.coinValue || 1;
      coinBank += coinValue;
      popTexts.push({
        x: obj.x,
        y: obj.y,
        text: `+${formatMoney(coinValue)}`,
        color: "#f1c40f",
        life: 1
      });
      playPopSound();
      spawnPopEffect(obj.x, obj.y);
      respawnObject(obj);
      updateCoinScoreboard(L);
      if (!levelEnding && coinBank >= L.coinTarget) levelComplete();
      continue;
    }

    // --- SCORE GOAL (Balloon Bash etc.) ---
    if (L.mechanic === "scoreGoal") {
      const val = obj.type.score || 0;
      score += val;
      if (score < 0) score = 0;
      scoreText.textContent = `Score ${score}/${L.winScore}`;

      popTexts.push({
        x: obj.x,
        y: obj.y,
        text: `${val > 0 ? "+" : ""}${val}`,
        color: val > 0 ? "#2ecc71" : "#e74c3c",
        life: 1
      });

      playPopSound();
      spawnPopEffect(obj.x, obj.y);
      respawnObject(obj);

      if (!levelEnding && score >= L.winScore) {
        setTimeout(() => levelComplete(), 250);
      }
      continue;
    }

    // --- DEFAULT HANDLER (collect / combo / scoreCollect etc.) ---
    handleScoreHit(obj, L);
  }
}

function handleScoreHit(o, L) {
  const val = o.type.score;

  if (L.mechanic === "comboGoal") {
    const now = Date.now();
    if (now - lastPopTime < (L.comboTime || 2000)) {
      comboCount++;
      comboTextTimer = 60;
    } else comboCount = 1;
    lastPopTime = now;
  }

  let addVal = val;
  if (L.mechanic === "comboGoal" && comboCount > 1) {
    addVal = val * comboCount;
  }

  if (L.mechanic === "collectGoal" || L.mechanic === "scoreCollect") {
    collected += 1;
    scoreText.textContent = `Collected ${collected}/${L.collectGoal}`;
    if (!levelEnding && collected >= L.collectGoal) levelComplete();
  } else {
    score += addVal;
    if (score < 0) score = 0;
    scoreText.textContent = `Score ${score}/${L.winScore}`;
    if (!levelEnding && score >= L.winScore) levelComplete();
  }

  popTexts.push({
    x: o.x,
    y: o.y,
    text:
      L.mechanic === "comboGoal" && comboCount > 1
        ? `Combo x${comboCount}! +${addVal}`
        : `${val > 0 ? "+" : ""}${val}`,
    color: val > 0 ? "#2ecc71" : "#e74c3c",
    life: 1
  });

  playPopSound();
  spawnPopEffect(o.x, o.y);
  respawnObject(o);
}

function respawnObject(o) {
  // ‚úÖ use consistent level reference
  const levelConfig = levels[currentLevel];
  o.x = canvas.width + Math.random() * 900;
  o.y = 150 + Math.random() * 250;

  let nextType = chooseObjectType(levelConfig);
  const currentNegatives = objects.filter(obj => obj.type.score < 0).length;
  if (nextType.score < 0 && currentNegatives >= 5)
    nextType = objectTypes.balloon;
  o.type = nextType;
}

function detectRescueHits(levelConfig) {
  babyDragons.forEach(baby => {
    if (baby.state !== "waiting") return;

    const distance = Math.hypot(dragon.x - baby.x, dragon.y - baby.y);
    if (distance < dragon.radius * 0.75 + 24) {
      baby.state = "flying";
      baby.slotIndex = rescueSlotQueue.shift();
      spawnBabyFire(baby.x, baby.y);

      popTexts.push({
        x: baby.x,
        y: baby.y,
        text: "Rescued!",
        color: "#ffd166",
        life: 1
      });

      playPopSound();
      rescuedCount += 1;

      if (isMathBubbleLevel(levelConfig)) {
        const breakpointIndex = Math.min(
          rescuedCount - 1,
          mathBubbleStageBreakpoints.length - 1
        );

        if (
          breakpointIndex >= 0 &&
          rescuedCount < levelConfig.rescueGoal
        ) {
          mathBubbleStage = mathBubbleStageBreakpoints[breakpointIndex];
        }

        if (rescuedCount >= levelConfig.rescueGoal) {
          mathBubbleStage = mathBubbleTokens.length || 0;
        }
      }

      updateRescueScoreboard(levelConfig);

      const reachedGoal = rescuedCount >= levelConfig.rescueGoal;
      if (!levelEnding && reachedGoal) {
        if (isMathBubbleLevel(levelConfig)) {
          if (mathBubbleRevealTimeout) clearTimeout(mathBubbleRevealTimeout);
          mathBubbleRevealTimeout = setTimeout(() => {
            if (!levelEnding) levelComplete();
          }, 1000);
        } else {
          levelComplete();
        }
      }
    }
  });
}
/************************************************************
 * BACKGROUND HELPERS
 ************************************************************/
function drawToyFactory() {
  const sky = ctx.createLinearGradient(0, 0, 0, canvas.height);
  sky.addColorStop(0, "#b3e5fc");
  sky.addColorStop(1, "#e1f5fe");
  ctx.fillStyle = sky;
  ctx.fillRect(0, 0, canvas.width, canvas.height);

  ctx.fillStyle = "#a1887f";
  ctx.fillRect(0, canvas.height * 0.85, canvas.width, canvas.height * 0.15);

  const baseY = canvas.height * 0.55;
  const baseH = canvas.height * 0.3;
  ctx.fillStyle = "#ffe082";
  ctx.fillRect(canvas.width * 0.15, baseY, canvas.width * 0.7, baseH);

  ctx.fillStyle = "#ff8a65";
  ctx.beginPath();
  ctx.moveTo(canvas.width * 0.12, baseY);
  ctx.lineTo(canvas.width * 0.5, baseY - 80);
  ctx.lineTo(canvas.width * 0.88, baseY);
  ctx.closePath();
  ctx.fill();

  ctx.fillStyle = "#ffcc80";
  ctx.fillRect(canvas.width * 0.35, baseY - 70, canvas.width * 0.3, 40);
  ctx.fillStyle = "#5d4037";
  ctx.font = "bold 28px Comic Sans MS";
  ctx.textAlign = "center";
  ctx.fillText("TOY STORE", canvas.width * 0.5, baseY - 40);

  const winY = baseY + 40;
  const winW = 80;
  const winH = 90;
  for (let x = canvas.width * 0.2; x < canvas.width * 0.8; x += 120) {
    const glass = ctx.createLinearGradient(0, 0, 0, winH);
    glass.addColorStop(0, "#ffffffcc");
    glass.addColorStop(1, "#81d4fa");
    ctx.fillStyle = glass;
    ctx.fillRect(x, winY, winW, winH);
    ctx.strokeStyle = "#4fc3f780";
    ctx.strokeRect(x, winY, winW, winH);
  }

  const doorX = canvas.width * 0.48;
  const doorY = baseY + 60;
  const doorW = 80;
  const doorH = 140;
  ctx.fillStyle = "#8d6e63";
  ctx.fillRect(doorX, doorY, doorW, doorH);
  ctx.fillStyle = "#d7ccc8";
  ctx.beginPath();
  ctx.arc(doorX + doorW * 0.75, doorY + doorH * 0.5, 6, 0, Math.PI * 2);
  ctx.fill();

  const now = Date.now() / 200;
  for (let i = 0; i < 14; i++) {
    const bulbX = canvas.width * 0.15 + (i + 0.5) * (canvas.width * 0.7 / 14);
    const bulbY = baseY - 6;
    const hue = (i * 25 + (now * 10) % 360) % 360;
    ctx.fillStyle = `hsl(${hue},90%,60%)`;
    ctx.beginPath();
    ctx.arc(bulbX, bulbY, 6, 0, Math.PI * 2);
    ctx.fill();
  }

  for (let i = 0; i < 3; i++) {
    const sx = canvas.width * (0.25 + i * 0.2);
    const sy = baseY - 80;
    ctx.fillStyle = "#b0bec5";
    ctx.fillRect(sx, sy - 60, 40, 60);
    const puffY = sy - 60 - (Date.now() / 20 + i * 50) % 140;
    ctx.fillStyle = "rgba(255,255,255,0.4)";
    ctx.beginPath();
    ctx.arc(sx + 20, puffY, 30, 0, Math.PI * 2);
    ctx.fill();
  }
}

function shouldShowToyStore(levelIndex) {
  const levelNumber = levelIndex + 1;
  return levelNumber >= 7 && (levelNumber - 7) % 10 === 0;
}

function drawClouds() {
  const layers = [
    { count: 5, speed: 0.25, size: 80, opacity: 0.35, yBase: canvas.height * 0.25 },
    { count: 4, speed: 0.4, size: 115, opacity: 0.25, yBase: canvas.height * 0.35 },
    { count: 3, speed: 0.6, size: 150, opacity: 0.18, yBase: canvas.height * 0.45 }
  ];

  layers.forEach((layer, layerIndex) => {
    for (let i = 0; i < layer.count; i++) {
      const offset = (performance.now() * layer.speed + i * 320) % (canvas.width + 260);
      const x = canvas.width - offset;
      const y = layer.yBase + Math.sin((i + layerIndex) * 1.3) * 18;

      ctx.save();
      ctx.globalAlpha = layer.opacity;
      ctx.translate(x, y);

      const puffCount = 4 + layerIndex;
      for (let p = 0; p < puffCount; p++) {
        const px = -layer.size * 0.5 + p * (layer.size / (puffCount - 1));
        const py = Math.sin(performance.now() / 900 + p) * 6;
        const radiusX = layer.size * (0.45 + Math.random() * 0.1);
        const radiusY = radiusX * 0.65;
        ctx.beginPath();
        ctx.ellipse(px, py, radiusX, radiusY, 0, 0, Math.PI * 2);
        ctx.fillStyle = "white";
        ctx.fill();
      }
      ctx.restore();
    }
  });

  ctx.globalAlpha = 1;
}

function drawScene(now) {
  ctx.clearRect(0, 0, canvas.width, canvas.height);

  const L = levels[currentLevel] || {};
  const showToyStore = shouldShowToyStore(currentLevel);

  // üß© DEBUG: see what the renderer thinks the current level and mechanic are
  console.log(
    "üé® drawScene running ‚Äî level", currentLevel,
    "name:", L.name,
    "mechanic:", L.mechanic,
    "escortActive:", escortState.active
  );

  drawWindLines();
  if (L.useStars) drawStars();
  if (showToyStore) drawToyFactory();
  if (currentLevel !== 4) drawClouds();

  if (isEscortLevel(L)) {
    console.log("‚úÖ isEscortLevel(L) detected ‚Äî calling drawEscortScene()");
    drawEscortScene(now);
  } else if (isRescueLevel()) {
    const level = levels[currentLevel];
    drawRescuePodBack();
    drawRescueSlotGuides();
    drawBabyDragons();
    drawRescuePodFront();
    if (level && isMathBubbleLevel(level)) {
      drawMathBubbleEquation(level);
    }
  } else if (isRhythmLevel()) {
    drawRhythmClouds(now);
  } else if (isAlphabetLevel()) {
    // Alphabet bubbles are drawn later via renderAlphabetLetters()
  } else {
    drawObjects();
  }

  renderAlphabetLetters(ctx);
  renderNumberNodes(ctx);

  drawBabyFireBursts();
  drawFire();
  drawFireGlow();
  drawDragon();

  drawPopTexts();
  if (comboTextTimer > 0) {
    comboTextTimer--;
    ctx.font = "26px Comic Sans MS";
    ctx.fillStyle = "rgba(255,255,255,0.8)";
    ctx.textAlign = "center";
    ctx.fillText(`Combo x${comboCount}!`, canvas.width / 2, 70);
  }
}
/************************************************************
 * ESCORT RENDERING
 ************************************************************/
function drawEscortScene(now) {
  drawEscortTrail();
  drawGoldenGate();
  drawMoonRockHazards();
  drawNimbusSprite(now);
  drawEscortProgressHUD();
  drawFinaleIndicator();
}

function drawEscortTrail() {
  const gradient = ctx.createLinearGradient(0, canvas.height * 0.2, 0, canvas.height * 0.8);
  gradient.addColorStop(0, "rgba(255,255,255,0.05)");
  gradient.addColorStop(0.5, "rgba(120,180,255,0.12)");
  gradient.addColorStop(1, "rgba(255,255,255,0.05)");
  ctx.fillStyle = gradient;
  ctx.beginPath();
  ctx.roundRect(canvas.width * 0.12, canvas.height * 0.28, canvas.width * 0.76, canvas.height * 0.44, 45);
  ctx.fill();
}

function drawGoldenGate() {
  const baseX = canvas.width * 0.78;
  const baseY = canvas.height * 0.36;
  const gateWidth = canvas.width * 0.16;
  const gateHeight = canvas.height * 0.38;
  const pillarWidth = gateWidth * 0.18;
  const innerGap = gateWidth - pillarWidth * 2;
  const now = performance.now();

  ctx.save();

  const pillarGradient = ctx.createLinearGradient(0, baseY, 0, baseY + gateHeight);
  pillarGradient.addColorStop(0, "#ffe9a3");
  pillarGradient.addColorStop(1, "#d59a32");

  ctx.fillStyle = pillarGradient;
  ctx.strokeStyle = "rgba(255,255,255,0.35)";
  ctx.lineWidth = 2;

  // Left pillar
  ctx.beginPath();
  ctx.roundRect(baseX, baseY, pillarWidth, gateHeight, 10);
  ctx.fill();
  ctx.stroke();

  // Right pillar
  ctx.beginPath();
  ctx.roundRect(baseX + gateWidth - pillarWidth, baseY, pillarWidth, gateHeight, 10);
  ctx.fill();
  ctx.stroke();

  // Crossbeams
  ctx.fillStyle = "rgba(255,240,200,0.8)";
  const beamCount = 4;
  for (let i = 0; i <= beamCount; i++) {
    const y = baseY + (i / beamCount) * gateHeight;
    ctx.fillRect(baseX + pillarWidth - 6, y - 3, innerGap + 12, 6);
  }

  // Lattice
  ctx.strokeStyle = "rgba(255,255,255,0.25)";
  ctx.lineWidth = 2;
  for (let i = 0; i < beamCount; i++) {
    const yTop = baseY + (i / beamCount) * gateHeight;
    const yBottom = baseY + ((i + 1) / beamCount) * gateHeight;
    ctx.beginPath();
    ctx.moveTo(baseX + pillarWidth, yTop);
    ctx.lineTo(baseX + pillarWidth + innerGap, yBottom);
    ctx.moveTo(baseX + pillarWidth + innerGap, yTop);
    ctx.lineTo(baseX + pillarWidth, yBottom);
    ctx.stroke();
  }

  // Portal core
  const portalX = baseX + pillarWidth + innerGap / 2;
  const portalY = baseY + gateHeight * 0.25;
  const portalRadius = innerGap * 0.45;

  const portalGradient = ctx.createRadialGradient(portalX, portalY, 10, portalX, portalY, portalRadius * 1.2);
  portalGradient.addColorStop(0, "rgba(255,255,255,0.95)");
  portalGradient.addColorStop(0.4, "rgba(255,215,150,0.8)");
  portalGradient.addColorStop(1, "rgba(255,180,70,0.15)");

  ctx.fillStyle = portalGradient;
  ctx.beginPath();
  ctx.arc(portalX, portalY, portalRadius * 1.2, 0, Math.PI * 2);
  ctx.fill();

  // Shimmer beams
  ctx.globalCompositeOperation = "lighter";
  const shimmer = 0.6 + Math.sin(now / 260) * 0.2;
  ctx.strokeStyle = `rgba(255,233,160,${shimmer})`;
  ctx.lineWidth = 6;
  ctx.beginPath();
  ctx.moveTo(portalX, baseY - 20);
  ctx.lineTo(portalX, baseY + gateHeight + 20);
  ctx.stroke();

  ctx.strokeStyle = `rgba(255,255,255,${shimmer * 0.7})`;
  ctx.lineWidth = 3;
  ctx.beginPath();
  ctx.moveTo(portalX - innerGap * 0.25, baseY);
  ctx.lineTo(portalX + innerGap * 0.25, baseY + gateHeight);
  ctx.moveTo(portalX + innerGap * 0.25, baseY);
  ctx.lineTo(portalX - innerGap * 0.25, baseY + gateHeight);
  ctx.stroke();

  // Sparkles
  ctx.fillStyle = "rgba(255,255,255,0.9)";
  for (let i = 0; i < 12; i++) {
    const angle = (now / 700 + i) % (Math.PI * 2);
    const radius = portalRadius * (0.6 + (i % 3) * 0.15);
    const sx = portalX + Math.cos(angle) * radius;
    const sy = portalY + Math.sin(angle) * radius;
    ctx.beginPath();
    ctx.arc(sx, sy, 2 + (i % 3), 0, Math.PI * 2);
    ctx.fill();
  }

  ctx.restore();
}

function drawNimbusSprite(now) {
  const cfg = getEscortConfig(levels[currentLevel]) || {};
  const maxHearts = cfg.maxStrikes ? Math.max(1, cfg.maxStrikes) : 5;
  const strikes = Math.min(maxHearts, Math.max(0, escortState.strikes || 0));
  const integrity = 1 - strikes / maxHearts;
  const { x, y } = escortState.spritePos;
  const bodyW = 120;
  const bodyH = 70;
  const scale = 0.48;
  const wobble = Math.sin(now / 260) * 3;
  const hitAge = escortState.lastHitAt ? now - escortState.lastHitAt : Infinity;
  const impactFlash = Math.max(0, 1 - hitAge / 350);

  ctx.save();
  ctx.translate(x, y + wobble);
  ctx.scale(scale, scale);

  // Drop shadow
  ctx.fillStyle = "rgba(0,0,0,0.2)";
  ctx.beginPath();
  ctx.ellipse(0, bodyH * 0.55, bodyW * 0.9, bodyH * 0.35, 0, 0, Math.PI * 2);
  ctx.fill();

  // Nimbus body
  ctx.save();
  const bodyGradient = ctx.createRadialGradient(-25, -18, 15, 0, 0, bodyW);
  bodyGradient.addColorStop(0, "rgba(255,255,255,0.98)");
  bodyGradient.addColorStop(0.4, "rgba(230,242,255,0.92)");
  bodyGradient.addColorStop(1, "rgba(160,200,255,0.78)");
  ctx.fillStyle = bodyGradient;
  ctx.beginPath();
  ctx.ellipse(0, 0, bodyW, bodyH, 0, 0, Math.PI * 2);
  ctx.fill();

  // Bite marks
  if (strikes > 0) {
    ctx.globalCompositeOperation = "destination-out";
    const chunks = Math.min(strikes, 3);
    for (let i = 0; i < chunks; i++) {
      const magnitude = strikes / maxHearts;
      const cx = -bodyW * (0.35 + i * 0.12);
      const cy = (i % 2 === 0 ? -1 : 1) * bodyH * 0.15;
      ctx.beginPath();
      ctx.ellipse(cx, cy, bodyW * 0.35 * magnitude, bodyH * 0.65, 0, 0, Math.PI * 2);
      ctx.fill();
    }
    ctx.globalCompositeOperation = "source-over";
  }
  ctx.restore();

  // Cracks
  if (strikes > 0) {
    ctx.strokeStyle = "rgba(140,160,210,0.9)";
    ctx.lineWidth = 3;
    for (let i = 0; i < strikes; i++) {
      const angle = (-0.4 + (i / Math.max(1, strikes - 1)) * 0.8) * Math.PI;
      ctx.beginPath();
      ctx.moveTo(6, 0);
      ctx.lineTo(6 + Math.cos(angle) * bodyW * 0.55, Math.sin(angle) * bodyH * 0.5);
      ctx.stroke();
    }
  }

  // Damage flash
  if (impactFlash > 0 || integrity < 0.7) {
    const alpha = Math.min(Math.max(impactFlash * 0.8, 0.05) + Math.max(0, 0.7 - integrity), 0.85);
    ctx.fillStyle = `rgba(255,70,70,${alpha})`;
    ctx.beginPath();
    ctx.ellipse(0, 0, bodyW, bodyH, 0, 0, Math.PI * 2);
    ctx.fill();
  }

  // Face
  ctx.fillStyle = "#1e1e1e";
  ctx.beginPath();
  ctx.arc(-18, -10, 5, 0, Math.PI * 2);
  ctx.arc(18, -10, 5, 0, Math.PI * 2);
  ctx.fill();

  ctx.strokeStyle = "rgba(30,30,30,0.9)";
  ctx.lineWidth = 4;
  ctx.beginPath();
  ctx.arc(0, 4, 16, 0, Math.PI);
  ctx.stroke();

  ctx.restore();
}

function drawMoonRockHazards() {
  escortState.hazards.forEach(h => {
    ctx.save();
    ctx.translate(h.x, h.y);
    ctx.rotate(h.spin || 0);
    const gradient = ctx.createRadialGradient(-5, -5, 2, 0, 0, h.radius + 6);
    gradient.addColorStop(0, "#fdf2e9");
    gradient.addColorStop(1, "#c49b63");
    ctx.fillStyle = gradient;
    ctx.beginPath();
    ctx.ellipse(0, 0, h.radius * 1.15, h.radius, 0, 0, Math.PI * 2);
    ctx.fill();

    ctx.fillStyle = "rgba(0,0,0,0.12)";
    for (let i = 0; i < 4; i++) {
      const pocketX = Math.cos(i * 1.4) * h.radius * 0.4;
      const pocketY = Math.sin(i * 1.4) * h.radius * 0.3;
      ctx.beginPath();
      ctx.arc(pocketX, pocketY, h.radius * 0.25, 0, Math.PI * 2);
      ctx.fill();
    }
    ctx.restore();
  });
}

function drawEscortProgressHUD() {
  const cfg = getEscortConfig(levels[currentLevel]);
  const barWidth = Math.min(420, canvas.width * 0.6);
  const barX = canvas.width / 2 - barWidth / 2;
  const barY = 40;

  ctx.fillStyle = "rgba(0,0,0,0.2)";
  ctx.roundRect(barX, barY, barWidth, 20, 10);
  ctx.fill();

  ctx.fillStyle = "rgba(255,215,120,0.85)";
  ctx.roundRect(barX, barY, barWidth * escortState.spriteProgress, 20, 10);
  ctx.fill();

  ctx.font = "18px Comic Sans MS";
  ctx.fillStyle = "#fff";
  ctx.textAlign = "center";
  ctx.fillText(`${cfg.goalName ?? "Gate"} ${(escortState.spriteProgress * 100).toFixed(0)}%`, canvas.width / 2, barY - 8);

  ctx.textAlign = "right";
  ctx.fillText(`Shields ${escortState.shields}/${cfg.targetShields}`, canvas.width - 30, 32);
  ctx.textAlign = "left";
  ctx.fillText(`${cfg.stormName ?? "Storm"} ‚Äì ${cfg.maxStrikes - escortState.strikes} hearts`, 30, 32);
  ctx.textAlign = "center";
}

function drawFinaleIndicator() {
  if (!escortState.finaleHold.active) return;
  const cfg = getEscortConfig(levels[currentLevel]);
  const holdPct = escortState.finaleHold.heldMs / cfg.finaleHoldMs;
  const meterWidth = 320;
  const meterHeight = 18;
  const x = canvas.width / 2 - meterWidth / 2;
  const y = 70;

  ctx.fillStyle = "rgba(0,0,0,0.3)";
  ctx.roundRect(x, y, meterWidth, meterHeight, 9);
  ctx.fill();

  ctx.fillStyle = "rgba(111,255,233,0.85)";
  ctx.roundRect(x, y, meterWidth * holdPct, meterHeight, 9);
  ctx.fill();

  ctx.font = "20px Comic Sans MS";
  ctx.fillStyle = "#fff";
  ctx.fillText("Hold to lift Nimbus!", canvas.width / 2, y + 40);
}

// Utility polyfill
if (!CanvasRenderingContext2D.prototype.roundRect) {
  CanvasRenderingContext2D.prototype.roundRect = function (x, y, width, height, radius) {
    const r = typeof radius === "number" ? radius : 0;
    this.beginPath();
    this.moveTo(x + r, y);
    this.lineTo(x + width - r, y);
    this.quadraticCurveTo(x + width, y, x + width, y + r);
    this.lineTo(x + width, y + height - r);
    this.quadraticCurveTo(x + width, y + height, x + width - r, y + height);
    this.lineTo(x + r, y + height);
    this.quadraticCurveTo(x, y + height, x, y + height - r);
    this.lineTo(x, y + r);
    this.quadraticCurveTo(x, y, x + r, y);
    this.closePath();
    return this;
  };
}

/************************************************************
 * GAME STATE MANAGEMENT
 ************************************************************/
const defaultLevelGradient = ["#2b5876", "#4e4376"];

function ensureGradient(gradient) {
  return Array.isArray(gradient) && gradient.length === 2
    ? gradient
    : defaultLevelGradient;
}

function resolveLevelForIndex(index) {
  const baseLevel = levels[index];
  if (!baseLevel) {
    console.warn(`No level data for index ${index}`);
    return null;
  }

  // Merge defaults and add missing levelNumber (fix for math‚Äëbubbles)
  const resolved = Object.assign(
    {
      name: `Level ${index + 1}`,
      mechanic: "scoreGoal",
      control: "flap",
      bgGradient: defaultLevelGradient,
      levelNumber: index + 1
    },
    baseLevel
  );

  resolved.bgGradient = ensureGradient(resolved.bgGradient);
  return resolved;
}
/************************************************************
 * GAME LOOP + PHYSICS
 ************************************************************/
function flapDragon(boost = 1) {
  ensureAudioContext();
  dragon.velocity = dragon.flapStrength * boost;
  dragon.y = Math.max(35, dragon.y - 2);
  addParticle();
  flightStarted = true;
  overlay.style.opacity = 0;
}

function lerp(a, b, t) {
  return a + (b - a) * t;
}

const keysPressed = new Set();

function applyDirectionalInput() {
  if (isRhythmLevel()) return;

  const leftActive = keysPressed.has("ArrowLeft") || keysPressed.has("KeyA");
  const rightActive = keysPressed.has("ArrowRight") || keysPressed.has("KeyD");

  if (!leftActive && !rightActive) return;

  const escortBoost = isEscortLevel() ? 0.6 : 0;
  const accel = isRescueLevel() ? 0.55 : 0.35 + escortBoost * 0.25;
  const maxSpeed = isRescueLevel() ? 7 : 5 + escortBoost * 2;

  if (leftActive && !rightActive) {
    dragon.vx = Math.max(dragon.vx - accel, -maxSpeed);
  } else if (rightActive && !leftActive) {
    dragon.vx = Math.min(dragon.vx + accel, maxSpeed);
  }
}

function updateDragonPhysics() {
  dragon.velocity += dragon.gravity;
  dragon.y += dragon.velocity;
  dragon.x += dragon.vx;
  dragon.vx *= 0.93;

  if (dragon.y > canvas.height - 60) {
    dragon.y = canvas.height - 60;
    dragon.velocity = -Math.abs(dragon.velocity) * 0.4;
  }
  if (dragon.y < 40) {
    dragon.y = 40;
    dragon.velocity = Math.abs(dragon.velocity) * 0.4;
  }
  if (dragon.x < 60) {
    dragon.x = 60;
    dragon.vx = 0;
  }
  if (dragon.x > canvas.width - 60) {
    dragon.x = canvas.width - 60;
    dragon.vx = 0;
  }
}
/************************************************************
 * ALPHABET TIMER + COLLECTION HELPERS  ‚úÖ (restores level¬†8)
 ************************************************************/
function updateAlphabetTimer(now = performance.now()) {
  if (!alphabetState.active) return;

  const elapsed = now - alphabetState.timerStart;
  const remaining = alphabetState.timerMs - elapsed;

  // optional fail‚Äëtimeout logic
  if (remaining <= 0 && !alphabetState.failTriggered) {
    alphabetState.failTriggered = true;
    popTexts.push({
      x: canvas.width / 2,
      y: canvas.height / 2 - 40,
      text: "Time up!",
      color: "#ff7675",
      life: 1.3
    });
    setTimeout(() => loadLevel(currentLevel), 1000);
  }
}

function checkAlphabetCollection() {
  if (!alphabetState.active) return;

  // simple overlap check between dragon and each alphabet bubble
  for (const node of alphabetState.letters) {
    if (!node.active) continue;

    const dx = dragon.x - node.x;
    const dy = dragon.y - node.y;
    const dist = Math.hypot(dx, dy);

    if (dist < dragon.radius + node.radius * 0.6) {
      node.active = false;
      alphabetState.collected.push(node.letter);

      popTexts.push({
        x: node.x,
        y: node.y,
        text: node.letter,
        color: "#ffe066",
        life: 1
      });
      playPopSound();

      // win once all target letters are collected
      if (
        alphabetState.collected.length >= alphabetState.targetLetters.length &&
        !levelEnding
      ) {
        levelComplete();
      }
    }
  }

  // prune inactive letters from draw list if you prefer
  alphabetState.letters = alphabetState.letters.filter(l => l.active);
}

/************************************************************
 * NUMBER TIMER + COLLECTION HELPERS  ‚úÖ (restores level¬†9)
 ************************************************************/
function updateNumberTimer(now = performance.now()) {
  // Prevent freeze if called on number levels
  if (!numberState) return;

  if (!numberState.startTime) numberState.startTime = now;
  numberState.elapsed = now - numberState.startTime;

  // Optional: you can add countdown or progression logic here later
}

function checkNumberCollection() {
  if (!numberState?.active) return;

  // pick whichever array the level actually uses
  const nodes = Array.isArray(numberState.numbers)
    ? numberState.numbers
    : Array.isArray(numberState.nodes)
    ? numberState.nodes
    : [];

  if (nodes.length === 0) {
    // leave a small trace for debugging
    console.warn("‚ö†Ô∏è checkNumberCollection: no number bubbles found", numberState);
    return;
  }

  for (const node of nodes) {
    if (!node?.active) continue;

    const dx = dragon.x - node.x;
    const dy = dragon.y - node.y;
    const dist = Math.hypot(dx, dy);

    // bubble pop test
    if (dist < (dragon.radius ?? 40) + (node.radius ?? 20) * 0.6) {
      node.active = false;

      if (!Array.isArray(numberState.collected)) numberState.collected = [];
      numberState.collected.push(node.value ?? node.num ?? "?");

      popTexts.push({
        x: node.x,
        y: node.y,
        text: String(node.value ?? node.num ?? ""),
        color: "#74b9ff",
        life: 1
      });

      if (typeof playPopSound === "function") playPopSound();

      // win condition
      const targetCount = numberState.targetNumbers?.length ?? numberState.sequence?.length ?? 0;
      if (numberState.collected.length >= targetCount && !levelEnding) {
        levelComplete();
      }
    }
  }

  // keep only active bubbles
  if (Array.isArray(numberState.numbers)) {
    numberState.numbers = nodes.filter(n => n.active);
  } else if (Array.isArray(numberState.nodes)) {
    numberState.nodes = nodes.filter(n => n.active);
  }
}

/************************************************************
 * MAIN GAME LOOP
 ************************************************************/
function isEscortLevel(level = levels[currentLevel]) {
  return level?.mechanic === "escortPulse";
}

function updateGame(delta, time) {
  if (isRescueLevel()) {
    updateBabyDragons();
  }

  if (isRhythmLevel()) {
    updateRhythmLevel(time);
  }

  if (alphabetState.active) {
    updateAlphabetTimer(time);
    checkAlphabetCollection();
  }
  // --- NUMBER LEVELS (safe guarded against missing functions or data) ---
  try {
    if (typeof isNumberLevel === "function" && isNumberLevel()) {
      if (typeof updateNumberTimer === "function") {
        updateNumberTimer(time);
      }
      if (typeof checkNumberCollection === "function") {
        checkNumberCollection();
      }
    }
  } catch (err) {
    console.warn("‚ö†Ô∏è Number level logic skipped due to error:", err);
  }

  applyDirectionalInput();
  updateDragonPhysics();

  // ‚úÖ Escort levels: update every frame to spawn hazards & progress Nimbus
  const L = levels[currentLevel];   // üîπ Get the actual level object once

  if (isEscortLevel(L)) {           // üîπ Pass it explicitly so both checks agree
    console.log("üöÄ updateGame ‚ûú calling updateEscortLevel() for escort mode", {
      levelIndex: currentLevel,
      name: L?.name,
      mechanic: L?.mechanic,
      escortActive: escortState.active
    });

    updateEscortLevel(delta, time, L); // ‚¨Ö pass the level object (optional but safe)
    return; // stop here to skip normal hit detection
  }

  // --- Normal (non-escort) level logic below ---
  if (!isRhythmLevel()) {
    const sustaining = keysPressed.has("Space") || keysPressed.has("ArrowUp");
    if (sustaining) {
      dragon.velocity = Math.min(dragon.velocity, -4);
    }
    detectHits();
  }
}

let lastTimestamp = 0;

function gameLoop(timestamp) {
  if (!lastTimestamp) {
    lastTimestamp = timestamp;
  }
  const delta = timestamp - lastTimestamp;
  lastTimestamp = timestamp;

  updateGame(delta, timestamp);
  drawScene(timestamp);

  requestAnimationFrame(gameLoop);
}

/************************************************************
 * ESCORT LOOP HELPERS ‚Äì hazard spawn diagnostics + safe timing
 ************************************************************/
function updateEscortLevel(delta, now) {
  const levelConfig = levels[currentLevel];
  if (!escortState.active || !levelConfig || levelEnding) return;

  const cfg = getEscortConfig(levelConfig);
  if (!cfg || !cfg.durationMs) return;

  // üß≠ Inspect escort progress every 1s
  if (Math.round(now) % 1000 < 20) {
    console.log("Escort tick:", {
      currentLevel,
      mech: levelConfig.mechanic,
      elapsed: escortState.elapsed,
      duration: cfg.durationMs,
      hazardBurstInterval: cfg.hazardBurstInterval,
      shields: escortState.shields,
      strikes: escortState.strikes,
      hazards: escortState.hazards?.length || 0
    });
  }

  // Initialise timers if needed
  if (escortState.elapsed === 0 || escortState.hazardTimer === undefined) {
    escortState.hazardTimer = 0;
    escortState.shieldDecayTimer = 0;
    escortState.moteTimer = 0;
  }

  escortState.elapsed += delta;
  const progress = Math.min(escortState.elapsed / cfg.durationMs, 1);
  escortState.spriteProgress = progress;
  updateEscortSpritePosition(progress);

  // --- hazard rhythm ---
  escortState.hazardTimer += delta;

  // üí¨ diagnostic logs each cycle
  if (escortState.hazardTimer >= (cfg.hazardBurstInterval || 1500)) {
    console.log("üí• SPAWN CALL ‚Äî timer hit threshold");
    escortState.hazardTimer = 0;
    spawnMoonRockHazard(cfg);
    console.log("‚ÄÉ‚ÄÉhazards after push:", escortState.hazards.length);
  } else if (Math.random() < delta / ((cfg.hazardBurstInterval || 1500) * 2.2)) {
    console.log("üí• RANDOM SPAWN CALL");
    spawnMoonRockHazard(cfg);
    console.log("‚ÄÉ‚ÄÉhazards after push:", escortState.hazards.length);
  }

  // --- shield decay ---
  escortState.shieldDecayTimer = (escortState.shieldDecayTimer ?? 0) + delta;
  if (
    escortState.shields > 0 &&
    escortState.shieldDecayTimer >= (cfg.shieldDecayMs || 3600)
  ) {
    escortState.shieldDecayTimer -= (cfg.shieldDecayMs || 3600);
    escortState.shields = Math.max(0, escortState.shields - 1);
    updateScoreboardForLevel(levelConfig);
  }

  // --- update hazards + HUD ---
  updateEscortHazards(delta, cfg);
  updateEscortLifeMeter(cfg);

  // --- check fail / finale ---
  if (escortState.strikes >= cfg.maxStrikes && !escortState.failTriggered) {
    triggerEscortFail("Nimbus overwhelmed!");
    return;
  }

  if (progress >= 1) {
    handleEscortFinale(delta, cfg);
  } else {
    escortState.finaleHold.active = false;
    escortState.finaleHold.heldMs = 0;
  }
}

function updateEscortSpritePosition(progress) {
  const startX = canvas.width * 0.18;
  const endX = canvas.width * 0.78;
  const eased =
    progress < 0.5
      ? 2 * progress * progress
      : -1 + (4 - 2 * progress) * progress;
  escortState.spritePos.x = lerp(startX, endX, eased);
  escortState.spritePos.y =
    canvas.height * 0.4 + Math.sin(progress * Math.PI * 2) * canvas.height * 0.06;
}

function spawnMoonRockHazard(cfg) {
  const baseSpeed = (cfg.moonRockSpeed || 520) / 1000;
  const yStart = canvas.height * 0.25 + Math.random() * canvas.height * 0.5;

  escortState.hazards.push({
    x: canvas.width + 80,
    y: yStart,
    vx: -baseSpeed * (0.75 + Math.random() * 0.4),
    vy: (Math.random() - 0.5) * 0.08,
    radius: 18 + Math.random() * 18,
    spin: Math.random() * Math.PI * 2,
    spinSpeed: (Math.random() - 0.5) * 0.006,
    active: true
  });
}

function updateEscortHazards(delta, cfg) {
  const sprite = escortState.spritePos;
  for (const h of escortState.hazards) {
    if (!h.active) continue;
    h.x += h.vx * delta;
    h.y += h.vy * delta;
    h.spin += (h.spinSpeed || 0) * delta;
    if (h.y < 80 || h.y > canvas.height - 80) h.vy *= -1;

    const spriteHit =
      Math.hypot(h.x - sprite.x, h.y - sprite.y) < h.radius + 42;
    if (spriteHit) {
      h.active = false;
      handleMoonRockStrike(cfg, h.x, h.y);
      continue;
    }

    const dragonHit =
      Math.hypot(h.x - dragon.x, h.y - dragon.y) < h.radius + dragon.radius * 0.65;
    if (dragonHit) {
      h.active = false;
      popTexts.push({
        x: h.x,
        y: h.y,
        text: "Blocked!",
        color: "#7bed9f",
        life: 1
      });
    }
  }

  escortState.hazards = escortState.hazards.filter(h => h.active && h.x > -120);
}

function handleMoonRockStrike(cfg, x = canvas.width / 2, y = canvas.height / 2) {
  const levelConfig = levels[currentLevel];
  if (escortState.shields > 0) {
    escortState.shields = Math.max(0, escortState.shields - 1);
    popTexts.push({
      x,
      y,
      text: "Shielded!",
      color: "#66d9ff",
      life: 1.1
    });
    updateScoreboardForLevel(levelConfig);
  } else {
    escortState.strikes += 1;
    popTexts.push({
      x,
      y,
      text: "Strike!",
      color: "#ff7675",
      life: 1
    });
    updateEscortLifeMeter(cfg);
  }
}

function updateEscortLifeMeter(cfg) {
  if (!isEscortLevel()) {
    lifeMeter.style.display = "none";
    return;
  }
  lifeMeter.style.display = "block";
  let html = "";
  for (let i = 0; i < cfg.maxStrikes; i++) {
    const lost = i < escortState.strikes;
    html += `<span class="${lost ? "lost" : ""}">${lost ? "ü§ç" : "‚ù§Ô∏è"}</span>`;
  }
  lifeMeter.innerHTML = html;
}

function handleEscortFinale(delta, cfg) {
  escortState.finaleHold.active = true;
  const holding =
    keysPressed.has("Space") ||
    keysPressed.has("ArrowUp") ||
    keysPressed.has("KeyW") ||
    keysPressed.has("Enter");
  const change = holding ? delta : -delta * 0.65;
  escortState.finaleHold.heldMs = Math.max(
    0,
    Math.min(cfg.finaleHoldMs, escortState.finaleHold.heldMs + change)
  );
  if (holding && escortState.finaleHold.heldMs >= cfg.finaleHoldMs && !levelEnding) {
    lifeMeter.style.display = "none";
    levelComplete();
  }
}

function triggerEscortFail(message = "Nimbus lost!") {
  if (escortState.failTriggered) return;
  escortState.failTriggered = true;
  levelEnding = true;
  popTexts.push({
    x: canvas.width / 2,
    y: canvas.height * 0.4,
    text: message,
    color: "#ffe066",
    life: 1.5
  });
  setTimeout(() => {
    lifeMeter.style.display = "none";
    levelEnding = false;
    loadLevel(currentLevel);
  }, 1400);
}
/************************************************************
 * ESCORT STATE RESET
 ************************************************************/
const escortState = {
  active: false,
  elapsed: 0,
  hazardTimer: 0,
  shieldDecayTimer: 0,
  moteTimer: 0,
  spriteProgress: 0,
  spritePos: { x: 0, y: 0 },
  hazards: [],
  shields: 0,
  strikes: 0,
  failTriggered: false,
  lastHitAt: 0,
  finaleHold: { active: false, heldMs: 0 }
};

function getEscortConfig(levelConfig) {
  return levelConfig && levelConfig.escort ? levelConfig.escort : {};
}

function resetEscortState(levelConfig) {
  const cfg = getEscortConfig(levelConfig);
  escortState.active = true;
  escortState.elapsed = 0;
  escortState.hazards = [];
  escortState.strikes = 0;
  escortState.shields = cfg.targetShields || 7;
  escortState.spriteProgress = 0;
  escortState.spritePos = {
    x: canvas.width * 0.2,
    y: canvas.height * 0.45
  };
  escortState.failTriggered = false;
  escortState.lastHitAt = 0;
  escortState.finaleHold = { active: false, heldMs: 0 };
}
/************************************************************
 * INPUT HANDLERS
 ************************************************************/
function handlePointer(evt) {
  ensureAudioContext();

  if (isEscortLevel()) {
    handleEscortTap();
    return;
  }

  if (isRhythmLevel()) {
    if (rhythmState.mode === "dualLane") {
      const lane = evt.clientX < canvas.width / 2 ? "left" : "right";
      handleRhythmInput(lane);
    } else {
      handleRhythmInput();
    }
  } else {
    flapDragon();
  }
}

canvas.addEventListener("pointerdown", evt => {
  focusCanvas();
  handlePointer(evt);
});

canvas.addEventListener("touchstart", e => {
  e.preventDefault();
  const t = e.changedTouches[0];
  if (!t) return;
  focusCanvas();
  handlePointer({ type: "pointerdown", clientX: t.clientX, clientY: t.clientY });
});
canvas.addEventListener("touchmove", e => e.preventDefault());
canvas.addEventListener("touchend", e => {
  e.preventDefault();
  handlePointer({ type: "pointerup" });
});

const controlKeys = new Set([
  "Space",
  "ArrowUp",
  "ArrowDown",
  "ArrowLeft",
  "ArrowRight",
  "Enter",
  "KeyA",
  "KeyD"
]);

/************************************************************
 * INPUT HANDLING: keyboard + touch + escort tap
 ************************************************************/
document.addEventListener("keydown", e => {
  if (controlKeys.has(e.code)) {
    e.preventDefault();
  }
  focusCanvas();

  // === Rhythm level controls ===
  if (typeof isRhythmLevel === "function" && isRhythmLevel()) {
    switch (e.code) {
      case "ArrowLeft":
      case "KeyA":
        handleRhythmInput("left");
        return;
      case "ArrowRight":
      case "KeyD":
        handleRhythmInput("right");
        return;
      case "ArrowUp":
      case "Space":
        handleRhythmInput();
        return;
    }
  }

  keysPressed.add(e.code);

  // === Escort‚Äëmode controls ===
  if (typeof isEscortLevel === "function" && isEscortLevel()) {
    if (e.code === "Space" || e.code === "ArrowUp" || e.code === "Enter") {
      handleEscortTap();
    } else if (e.code === "ArrowLeft" || e.code === "KeyA") {
      dragon.vx -= 1.25;
    } else if (e.code === "ArrowRight" || e.code === "KeyD") {
      dragon.vx += 1.25;
    }
    return; // stop normal controls
  }

  // === Default flight controls ===
  if (e.code === "Space" || e.code === "ArrowUp") {
    flapDragon();
  } else if (e.code === "ArrowLeft") {
    dragon.vx -= 1.5;
  } else if (e.code === "ArrowRight") {
    dragon.vx += 1.5;
  }
});

document.addEventListener("keyup", e => {
  if (controlKeys.has(e.code)) {
    e.preventDefault();
  }

  keysPressed.delete(e.code);

  if (e.code === "ArrowLeft" || e.code === "ArrowRight") {
    if (!keysPressed.has("ArrowLeft") && !keysPressed.has("ArrowRight")) {
      dragon.vx *= 0.4;
    }
  }
});

// --- Touch controls ---
const touchControls = document.getElementById("touchControls");
const btnLeft  = document.getElementById("btnLeft");
const btnFlap  = document.getElementById("btnFlap");
const btnRight = document.getElementById("btnRight");

if (btnLeft && btnRight && btnFlap) {
  btnLeft.ontouchstart  = () => keysPressed.add("ArrowLeft");
  btnLeft.ontouchend    = () => keysPressed.delete("ArrowLeft");
  btnRight.ontouchstart = () => keysPressed.add("ArrowRight");
  btnRight.ontouchend   = () => keysPressed.delete("ArrowRight");
  btnFlap.ontouchstart  = () => {
    if (typeof isRhythmLevel === "function" && isRhythmLevel()) return handleRhythmInput();
    if (typeof isEscortLevel === "function" && isEscortLevel()) return handleEscortTap();
    flapDragon();
  };
}

// --- Escort‚Äëtap handler ---
function handleEscortTap() {
  if (typeof isEscortLevel !== "function" || !isEscortLevel() || levelEnding) return;
  ensureAudioContext();

  escortState.lastTapTime = performance.now();

  // restore lift so dragon climbs like normal flap
  rhythmTapBoost(0.55);
  flapDragon();

  popTexts.push({
    x: escortState.spritePos.x,
    y: escortState.spritePos.y - 60,
    text: "Stay close!",
    color: "#f8f0ff",
    life: 0.7
  });
}

/************************************************************
 * LEVEL SKIP ‚Äî canonical version from working build
 ************************************************************/
function skipLevel() {
  const next = (currentLevel + 1) % levels.length;
  if (typeof loadLevel === "function") {
    loadLevel(next);
  } else {
    console.warn("‚ö†Ô∏è‚ÄØloadLevel() not defined yet ‚Äî cannot skip level.");
  }
}

// --- Focus handling for accessibility ---
const clearSkipFocus = () => {
  if (document.activeElement === skipBtn) {
    skipBtn.blur();
  }
};

skipBtn.type = "button";
skipBtn.tabIndex = -1;

skipBtn.addEventListener("focus", clearSkipFocus);
skipBtn.addEventListener("pointerdown", clearSkipFocus);
skipBtn.addEventListener("keydown", e => {
  if (e.code === "Space" || e.code === "Enter") {
    e.preventDefault();
    clearSkipFocus();
  }
});

function loadLevel(index = 0) {
  const safeIndex = Math.max(0, Math.min(levels.length - 1, index));
  const level = resolveLevelForIndex(safeIndex);
  if (!level) {
    console.warn("‚ö†Ô∏è No level config for index", safeIndex);
    return;
  }

  currentLevel = safeIndex;
  currentLevelIndex = safeIndex;
  flightStarted = false;
  levelEnding = false;

  score = 0;
  coinBank = 0;
  collected = 0;
  rescuedCount = 0;
  comboCount = 0;
  comboTextTimer = 0;
  popTexts.length = 0;

  winOverlay.style.display = "none";
  overlay.style.opacity = 1;

  const levelNumber = level.levelNumber ?? safeIndex + 1;
  levelLabel.textContent = `Level ${levelNumber}: ${level.name || "Adventure"}`;

const gradient = ensureGradient(level.bgGradient);
document.body.style.background = `linear-gradient(to bottom, ${gradient[0]}, ${gradient[1]})`;

if (isMathBubbleLevel(level)) {
  currentMathEquation = level.mathEquation || "2 + 2 = 4";

  mathBubbleTokens = currentMathEquation.split(/\s+/).filter(Boolean);
  const rescueGoal = Math.max(1, level.rescueGoal || 1);

  mathBubbleStageBreakpoints = Array.from(
    { length: Math.max(0, rescueGoal - 1) },
    (_, idx) => {
      const tokensToShow = (idx + 1) * 2;
      return Math.min(mathBubbleTokens.length - 1, tokensToShow);
    }
  );

  mathBubbleStage = 0;
} else {
  currentMathEquation = "";
  mathBubbleStage = 0;
  mathBubbleTokens = [];
  mathBubbleStageBreakpoints = [];
}

if (mathBubbleRevealTimeout) {
  clearTimeout(mathBubbleRevealTimeout);
  mathBubbleRevealTimeout = null;
}

resetAlphabetState(level);
  resetNumberState(level);
  resetRhythmState(level);
  resetRescueState();
  escortState.active = false;

  objects.length = 0;

  if (isEscortLevel(level)) {
    resetEscortState(level);
    updateEscortLifeMeter(getEscortConfig(level));
  } else {
    lifeMeter.style.display = "none";
  }

  const isSpecialLevel =
    isRescueLevel(level) ||
    isRhythmLevel(level) ||
    isEscortLevel(level) ||
    isAlphabetLevel(level) ||
    isNumberLevel(level);

  if (!isSpecialLevel) {
    for (let i = 0; i < 8; i++) {
      objects.push({
        x: Math.random() * canvas.width,
        y: 120 + Math.random() * 260,
        radius: 25 + Math.random() * 20,
        type: chooseObjectType(level)
      });
    }
  }

  if (isRescueLevel(level)) {
    babyDragons = generateBabyDragons(level.rescueGoal || 5);
    rescueSlotQueue = [...Array(podSlotOffsets.length).keys()];
  }

  if (isRhythmLevel(level)) {
    updateLifeMeter();
  }

  updateScoreboardForLevel(level);
  pickMusicForLevel(safeIndex);
}

window.addEventListener("keydown", e => {
  if (
    (e.code === "Space" || e.code === "Enter") &&
    document.activeElement === skipBtn
  ) {
    e.preventDefault();
    clearSkipFocus();
  }
});

skipBtn.addEventListener("click", () => {
  skipLevel();
  clearSkipFocus();
});

clearSkipFocus();

/************************************************************
 * START GAME ‚Äî safe entry‚Äëpoint (correctly balanced)
 ************************************************************/
window.addEventListener("DOMContentLoaded", () => {
  try {
    if (typeof loadLevel === "function") {
      loadLevel(0); // start at level‚ÄØ1
    } else {
      console.error("‚ùå‚ÄØloadLevel() is not defined‚ÄØ‚Äî‚ÄØcheck script order.");
    }

    if (typeof gameLoop === "function") {
      requestAnimationFrame(gameLoop); // begin continuous update‚ÄØ&‚ÄØdraw
    } else {
      console.error("‚ùå‚ÄØgameLoop() is not defined‚ÄØ‚Äî‚ÄØverify it‚Äôs above this line.");
    }
  } catch (err) {
    console.error("üí•‚ÄØStartup‚ÄØerror:", err);
  }
}); // ‚úÖ closes event listener properly

</script>
</body>
</html>





















